#!/bin/bash
# DockUp: The Zero-Bloat PaaS CLI
# Usage: 
#   ./dockup user@vps-ip setup      -> Run once to install Docker/Agent on VPS
#   ./dockup user@vps-ip init       -> Run inside a git repo to deploy it
#   ./dockup user@vps-ip deploy     -> Unified: setup + init + deploy
#   ./dockup user@vps-ip list       -> List all registered apps
#   ./dockup user@vps-ip disconnect -> Unlink project (keeps app directory)
#   ./dockup user@vps-ip remove     -> Delete project completely

set -e

# Get script directory for module loading
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Version - update this when creating new tags
DOCKUP_VERSION="1.1.3"
DOCKUP_REPO="Moe1211/dockup"

# Load modular components if they exist
# This allows gradual migration to modular structure
if [ -f "$SCRIPT_DIR/lib/colors.sh" ]; then
    source "$SCRIPT_DIR/lib/colors.sh"
else
    # Fallback to inline colors
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    RED='\033[0;31m'
    BLUE='\033[0;34m'
    NC='\033[0m'
fi

# Load utility modules
[ -f "$SCRIPT_DIR/lib/utils.sh" ] && source "$SCRIPT_DIR/lib/utils.sh"
[ -f "$SCRIPT_DIR/lib/version.sh" ] && source "$SCRIPT_DIR/lib/version.sh"
[ -f "$SCRIPT_DIR/lib/loading.sh" ] && source "$SCRIPT_DIR/lib/loading.sh"

# Load interactive modules
[ -f "$SCRIPT_DIR/interactive/remotes.sh" ] && source "$SCRIPT_DIR/interactive/remotes.sh"
[ -f "$SCRIPT_DIR/interactive/apps.sh" ] && source "$SCRIPT_DIR/interactive/apps.sh"
[ -f "$SCRIPT_DIR/interactive/menu.sh" ] && source "$SCRIPT_DIR/interactive/menu.sh"

# Load command modules (if they exist, they'll override the functions below)
[ -f "$SCRIPT_DIR/commands/version.sh" ] && source "$SCRIPT_DIR/commands/version.sh"
[ -f "$SCRIPT_DIR/commands/list.sh" ] && source "$SCRIPT_DIR/commands/list.sh"

# Fallback print_version if not loaded from utils
if ! type print_version >/dev/null 2>&1; then
    print_version() {
        echo -e "${BLUE}DockUp v${DOCKUP_VERSION}${NC}"
    }
fi

# --- Command: VERSION (Show version information) ---
# Note: If commands/version.sh exists, it will override this function
if ! type cmd_version >/dev/null 2>&1; then
cmd_version() {
    echo -e "${BLUE}DockUp Version Information${NC}"
    echo ""
    echo -e "${BLUE}Installed Version:${NC} v${DOCKUP_VERSION}"
    
    # Try to get latest version
    local latest_version=$(get_latest_version 2>/dev/null || echo "")
    
    if [ -n "$latest_version" ]; then
        echo -e "${BLUE}Latest Version:${NC}   v${latest_version}"
        echo ""
        
        # Compare versions
        compare_versions "$DOCKUP_VERSION" "$latest_version"
        local comparison_result=$?
        
        if [ $comparison_result -eq 0 ]; then
            # Installed > Latest (shouldn't happen, but handle it)
            echo -e "${YELLOW}Status:${NC} Installed version is newer than latest (v${DOCKUP_VERSION} > v${latest_version})"
        elif [ $comparison_result -eq 1 ]; then
            # Installed < Latest
            echo -e "${YELLOW}Status:${NC} Update available (v${DOCKUP_VERSION} < v${latest_version})"
            echo ""
            echo -e "${YELLOW}Update:${NC} curl -fsSL https://raw.githubusercontent.com/${DOCKUP_REPO}/main/install-global.sh | bash"
        elif [ $comparison_result -eq 2 ]; then
            # Installed == Latest
            echo -e "${GREEN}Status:${NC} Up to date (v${DOCKUP_VERSION} == v${latest_version})"
        fi
    else
        echo -e "${BLUE}Latest Version:${NC}   ${YELLOW}(unable to fetch)${NC}"
        echo ""
        echo -e "${YELLOW}Status:${NC} Could not check for updates (network issue or API unavailable)"
    fi
    echo ""
}
fi  # End of cmd_version fallback

# --- Version Checking Functions ---
# Note: If lib/version.sh exists, these will be overridden

# Compare two semantic versions (returns 0 if v1 > v2, 1 if v1 < v2, 2 if equal)
# Usage: compare_versions "1.0.5" "1.0.6" -> returns 1 (1.0.5 < 1.0.6)
compare_versions() {
    local v1="$1"
    local v2="$2"
    
    # Remove 'v' prefix if present
    v1="${v1#v}"
    v2="${v2#v}"
    
    # Split versions into arrays
    IFS='.' read -ra v1_parts <<< "$v1"
    IFS='.' read -ra v2_parts <<< "$v2"
    
    # Compare each part
    local max_len=${#v1_parts[@]}
    if [ ${#v2_parts[@]} -gt $max_len ]; then
        max_len=${#v2_parts[@]}
    fi
    
    for ((i=0; i<max_len; i++)); do
        local v1_part="${v1_parts[$i]:-0}"
        local v2_part="${v2_parts[$i]:-0}"
        
        # Remove any non-numeric suffix (e.g., "1.0.5-beta" -> "1.0.5")
        v1_part="${v1_part%%[!0-9]*}"
        v2_part="${v2_part%%[!0-9]*}"
        
        if [ "$v1_part" -gt "$v2_part" ]; then
            return 0  # v1 > v2
        elif [ "$v1_part" -lt "$v2_part" ]; then
            return 1  # v1 < v2
        fi
    done
    
    return 2  # v1 == v2
}

# Get latest version from GitHub tags API
# Fetches all tags, sorts them by semantic version, and returns the latest
get_latest_version() {
    local cache_file="${HOME}/.dockup_version_cache"
    local cache_age=3600  # Cache for 1 hour (3600 seconds)
    local latest_version=""
    
    # Check cache first
    if [ -f "$cache_file" ]; then
        # Get cache file modification time (works on both macOS and Linux)
        # Try macOS format first, then Linux format
        local cache_time=$(stat -f "%m" "$cache_file" 2>/dev/null || stat -c "%Y" "$cache_file" 2>/dev/null || echo "0")
        
        if [ "$cache_time" != "0" ]; then
            local current_time=$(date +%s)
            local age=$((current_time - cache_time))
            
            if [ $age -lt $cache_age ]; then
                latest_version=$(cat "$cache_file" 2>/dev/null || echo "")
                if [ -n "$latest_version" ]; then
                    echo "$latest_version"
                    return 0
                fi
            fi
        fi
    fi
    
    # Fetch tags from GitHub API (non-blocking, with timeout)
    local tags_response=$(curl -s --max-time 5 --connect-timeout 3 \
        "https://api.github.com/repos/${DOCKUP_REPO}/tags?per_page=100" 2>/dev/null)
    
    if [ -z "$tags_response" ] || ! echo "$tags_response" | grep -q '"name"'; then
        # Failed to fetch or no tags found
        echo ""
        return 1
    fi
    
    # Extract all version tags and find the latest by semantic version
    # Tags API returns in reverse chronological order, but we need semantic sorting
    local temp_file=$(mktemp)
    echo "$tags_response" | grep -o '"name": "[^"]*"' | \
        cut -d'"' -f4 | \
        grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | \
        sed 's/^v//' > "$temp_file"
    
    if [ ! -s "$temp_file" ]; then
        rm -f "$temp_file"
        echo ""
        return 1
    fi
    
    # Sort versions semantically and get the latest
    # Read all versions, compare them, and find the maximum
    latest_version=""
    while IFS= read -r version; do
        if [ -z "$latest_version" ]; then
            latest_version="$version"
        else
            compare_versions "$latest_version" "$version"
            local result=$?
            # If latest_version < version, update latest_version
            if [ $result -eq 1 ]; then
                latest_version="$version"
            fi
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    # If we got a version, cache it
    if [ -n "$latest_version" ]; then
        echo "$latest_version" > "$cache_file" 2>/dev/null || true
        echo "$latest_version"
        return 0
    fi
    
    # Return empty if no valid version found
    echo ""
    return 1
}

# Check for updates and display notification if available
check_for_updates() {
    # Skip check if DOCKUP_SKIP_UPDATE_CHECK is set
    if [ -n "${DOCKUP_SKIP_UPDATE_CHECK:-}" ]; then
        return 0
    fi
    
    # Get latest version (non-blocking, cached)
    # Use a subshell to prevent set -e from affecting the main script
    local latest_version=""
    latest_version=$(get_latest_version 2>/dev/null || echo "") || true
    
    # If we couldn't get latest version, silently continue
    if [ -z "$latest_version" ]; then
        return 0
    fi
    
    # Compare versions (don't fail if comparison fails)
    compare_versions "$DOCKUP_VERSION" "$latest_version" || true
    local comparison_result=$?
    
    # If installed version is less than latest, show update message
    if [ $comparison_result -eq 1 ]; then
        echo ""
        echo -e "${YELLOW}üì¶ Update Available!${NC}"
        echo -e "${YELLOW}   You're running v${DOCKUP_VERSION}, but v${latest_version} is available.${NC}"
        echo -e "${YELLOW}   Update: curl -fsSL https://raw.githubusercontent.com/${DOCKUP_REPO}/main/install-global.sh | bash${NC}"
        echo ""
    fi
    
    return 0
}

# Try to find main.go in multiple locations:
# 1. Same directory as script (local development)
# 2. ~/.local/share/dockup/main.go (user install)
# 3. /usr/local/share/dockup/main.go (system install)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/main.go" ]; then
    AGENT_SRC="$SCRIPT_DIR/main.go"
elif [ -f "$HOME/.local/share/dockup/main.go" ]; then
    AGENT_SRC="$HOME/.local/share/dockup/main.go"
elif [ -f "/usr/local/share/dockup/main.go" ]; then
    AGENT_SRC="/usr/local/share/dockup/main.go"
else
    AGENT_SRC="main.go"  # Fallback: current directory
fi
BINARY_NAME="dockup-agent"

# --- Helper: Get GitHub App installation token from VPS ---
get_github_token() {
    local remote="$1"
    # This will be called from the VPS side via the agent
    # For now, we'll handle token generation in the Go agent
    echo ""
}

# --- Helper: Embedded Server Installer ---
# This generates the installer script dynamically so you don't need to manage two files.
generate_installer_script() {
cat << 'EOF' > _remote_install.sh
#!/bin/bash
set -e
echo ">> Installing Dependencies..."
apt-get update -qq && apt-get install -y -qq git jq curl

if ! command -v docker &> /dev/null; then curl -fsSL https://get.docker.com | sh; fi

echo ">> Setting up Directories..."
mkdir -p /opt/dockup/apps /etc/dockup
if [ ! -f /etc/dockup/registry.json ]; then echo "{}" > /etc/dockup/registry.json; fi

echo ">> Installing Agent..."
mv dockup-agent /usr/local/bin/
chmod +x /usr/local/bin/dockup-agent

echo ">> Configuring Systemd..."
cat <<EOT > /etc/systemd/system/dockup.service
[Unit]
Description=DockUp Agent
After=network.target docker.service

[Service]
ExecStart=/usr/local/bin/dockup-agent -port 8080 -config /etc/dockup/registry.json
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
EOT

# Stop any existing dockup processes that might be holding the port
pkill -f dockup-agent || true
sleep 2

systemctl daemon-reload
systemctl enable --now dockup

echo ">> GitHub App configuration required"
echo "   Run 'dockup user@vps-ip configure-github-app' to set up GitHub App credentials"
EOF
}

# --- Command: SETUP (Provision VPS) ---
cmd_setup() {
    # REMOTE is passed as first argument
    SETUP_REMOTE="$1"
    
    if [ -z "$SETUP_REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host setup${NC}" >&2
        exit 1
    fi
    
    # Check for updates (don't fail if this fails)
    check_for_updates || true

    print_version
    echo ""
    echo -e "${GREEN}üî® Building Agent for Linux...${NC}"
    if [ -f "$AGENT_SRC" ]; then
        # Build in the directory containing main.go to ensure go.mod is found
        AGENT_DIR=$(dirname "$AGENT_SRC")
        AGENT_FILE=$(basename "$AGENT_SRC")
        if [ -f "$AGENT_DIR/go.mod" ]; then
            # Ensure go.sum exists or generate it
            if [ ! -f "$AGENT_DIR/go.sum" ]; then
                echo -e "${BLUE}   Generating go.sum...${NC}"
                (cd "$AGENT_DIR" && go mod tidy 2>&1 || go mod download 2>&1 || true)
            fi
            # Build from the directory containing go.mod
            (cd "$AGENT_DIR" && env GOOS=linux GOARCH=amd64 go build -o "$(pwd)/$BINARY_NAME" "$AGENT_FILE")
            # Move binary to current directory if built elsewhere
            if [ -f "$AGENT_DIR/$BINARY_NAME" ] && [ "$AGENT_DIR" != "." ]; then
                mv "$AGENT_DIR/$BINARY_NAME" "./$BINARY_NAME"
            fi
        else
            # Fallback: build from current directory if go.mod is here
            if [ -f "./go.mod" ]; then
                # Ensure go.sum exists
                if [ ! -f "./go.sum" ]; then
                    echo -e "${BLUE}   Generating go.sum...${NC}"
                    go mod tidy 2>&1 || go mod download 2>&1 || true
                fi
                env GOOS=linux GOARCH=amd64 go build -o $BINARY_NAME "$AGENT_SRC"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  go.mod not found, building without module support...${NC}"
                env GOOS=linux GOARCH=amd64 go build -o $BINARY_NAME "$AGENT_SRC"
            fi
        fi
    elif [ ! -f "$BINARY_NAME" ]; then
        echo -e "${RED}Error: Could not find main.go${NC}"
        echo -e "${YELLOW}Tried:${NC}"
        echo -e "${YELLOW}  - $SCRIPT_DIR/main.go${NC}"
        echo -e "${YELLOW}  - $HOME/.local/share/dockup/main.go${NC}"
        echo -e "${YELLOW}  - /usr/local/share/dockup/main.go${NC}"
        echo -e "${YELLOW}  - ./main.go${NC}"
        echo ""
        echo -e "${YELLOW}Install DockUp globally:${NC}"
        echo -e "${BLUE}curl -fsSL https://raw.githubusercontent.com/Moe1211/dockup/main/install-global.sh | bash${NC}"
        exit 1
    fi

    echo -e "${GREEN}üöÄ Uploading Agent and Installer to $SETUP_REMOTE...${NC}"
    generate_installer_script # Create temp script
    
    if ! scp -q $BINARY_NAME _remote_install.sh $SETUP_REMOTE:~/ 2>&1; then
        echo -e "${RED}‚ùå Failed to upload files to $SETUP_REMOTE${NC}" >&2
        echo -e "${YELLOW}   Check SSH connectivity: ssh $SETUP_REMOTE 'echo test'${NC}" >&2
        rm -f _remote_install.sh $BINARY_NAME 2>/dev/null || true
        exit 1
    fi

    echo -e "${GREEN}‚öôÔ∏è  Running Remote Installer...${NC}"
    if ! ssh $SETUP_REMOTE "chmod +x _remote_install.sh && ./_remote_install.sh" 2>&1; then
        echo -e "${RED}‚ùå Failed to run installer on $SETUP_REMOTE${NC}" >&2
        echo -e "${YELLOW}   Check SSH access and permissions${NC}" >&2
        rm -f _remote_install.sh $BINARY_NAME 2>/dev/null || true
        exit 1
    fi
    
    # Cleanup
    rm _remote_install.sh $BINARY_NAME
    echo ""
    echo -e "${GREEN}‚úÖ VPS Setup Complete!${NC}"
    echo ""
    echo -e "${YELLOW}üìã Important Next Steps:${NC}"
    echo ""
    echo -e "${YELLOW}1. Configure GitHub App credentials:${NC}"
    echo "   Run: dockup $SETUP_REMOTE configure-github-app"
    echo "   See GITHUB_APP_SETUP.md for detailed instructions"
    echo ""
    echo -e "${YELLOW}2. Make sure your VPS firewall allows port 8080:${NC}"
    echo "   The agent listens on port 8080 for webhooks"
    echo ""
    echo -e "${YELLOW}3. Run 'deploy' command from your project directory:${NC}"
    echo "   cd /path/to/your-project"
    echo "   ./dockup $SETUP_REMOTE deploy"
    echo ""
}

# --- Helper: Copy .env files to VPS ---
copy_env_files() {
    local REMOTE="$1"
    local APP_NAME="$2"
    
    # Check if app directory exists on VPS
    if ! ssh "$REMOTE" "test -d /opt/dockup/apps/$APP_NAME" 2>/dev/null; then
        # Directory doesn't exist yet, skip (will be created during clone)
        return 0
    fi
    
    # Check if we're in a git repository to find project root
    local PROJECT_ROOT=""
    if git rev-parse --show-toplevel > /dev/null 2>&1; then
        PROJECT_ROOT=$(git rev-parse --show-toplevel)
    else
        PROJECT_ROOT="."
    fi
    
    # Find .env files in project root
    local env_files=()
    if [ -f "$PROJECT_ROOT/.env" ]; then
        env_files+=("$PROJECT_ROOT/.env")
    fi
    if [ -f "$PROJECT_ROOT/.env.production" ]; then
        env_files+=("$PROJECT_ROOT/.env.production")
    fi
    if [ -f "$PROJECT_ROOT/.env.prod" ]; then
        env_files+=("$PROJECT_ROOT/.env.prod")
    fi
    if [ -f "$PROJECT_ROOT/.env.staging" ]; then
        env_files+=("$PROJECT_ROOT/.env.staging")
    fi
    
    # If no .env files found, return early
    if [ ${#env_files[@]} -eq 0 ]; then
        return 0
    fi
    
    # Ask user if they want to copy .env files
    echo ""
    echo -e "${BLUE}üìã Copy .env files using DockUp?${NC}"
    echo -e "${YELLOW}   (We can't see your data - we simply execute the ssh copy command for you :)${NC}"
    echo ""
    echo -e "   Found ${#env_files[@]} .env file(s):"
    for env_file in "${env_files[@]}"; do
        echo -e "   - $(basename "$env_file")"
    done
    echo ""
    read -p "Copy .env files to VPS? (y/N): " COPY_ENV
    
    if [ "$COPY_ENV" != "y" ] && [ "$COPY_ENV" != "Y" ]; then
        return 0
    fi
    
    # Ensure app directory exists on VPS
    ssh "$REMOTE" "mkdir -p /opt/dockup/apps/$APP_NAME" 2>/dev/null || true
    
    # Copy each .env file
    echo ""
    echo -e "${BLUE}üì§ Copying .env files...${NC}"
    local success_count=0
    local fail_count=0
    
    for env_file in "${env_files[@]}"; do
        local filename=$(basename "$env_file")
        echo -e "   Copying ${BLUE}$filename${NC}..."
        
        if scp -q "$env_file" "$REMOTE:/opt/dockup/apps/$APP_NAME/$filename" 2>/dev/null; then
            echo -e "   ${GREEN}‚úì${NC} $filename copied successfully"
            ((success_count++))
        else
            echo -e "   ${RED}‚úó${NC} Failed to copy $filename"
            ((fail_count++))
        fi
    done
    
    echo ""
    if [ $success_count -gt 0 ]; then
        echo -e "${GREEN}‚úÖ Successfully copied $success_count .env file(s)${NC}"
    fi
    if [ $fail_count -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Failed to copy $fail_count .env file(s)${NC}"
        echo -e "${YELLOW}   You can copy them manually:${NC}"
        echo -e "${YELLOW}   scp .env $REMOTE:/opt/dockup/apps/$APP_NAME/${NC}"
    fi
    echo ""
}

# --- Command: INIT (Register Repo) ---
cmd_init() {
    # Check for updates
    check_for_updates
    
    REMOTE="$1"
    if [ -z "$REMOTE" ]; then echo -e "${RED}Usage: ./dockup user@host init${NC}"; exit 1; fi

    print_version
    echo ""

    # 1. Context Detection - Must be run from a Git repository
    if ! git rev-parse --show-toplevel > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Error: Not a Git repository${NC}"
        echo -e "${YELLOW}The 'init' command must be run from inside your project's Git repository.${NC}"
        echo -e "${YELLOW}Example: cd /path/to/your-app && ./dockup user@vps-ip init${NC}"
        exit 1
    fi

    APP_NAME=$(basename `git rev-parse --show-toplevel`)
    REPO_URL=$(git config --get remote.origin.url)
    
    if [ -z "$REPO_URL" ]; then
        echo -e "${RED}‚ùå Error: No Git remote found${NC}"
        echo -e "${YELLOW}Please add a remote origin to your repository:${NC}"
        echo -e "${YELLOW}  git remote add origin <your-repo-url>${NC}"
        exit 1
    fi
    
    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    SECRET=$(openssl rand -hex 20)

    echo -e "${GREEN}üöÄ Initializing '$APP_NAME' on $REMOTE...${NC}"
    echo ""

    # 2. Remote Provisioning
    # Check if GitHub App is configured
    echo -e "${BLUE}üì¶ Setting up on VPS...${NC}"
    GITHUB_APP_CONFIGURED=$(ssh $REMOTE "test -f /etc/dockup/github-app.json && echo 'yes' || echo 'no'" 2>/dev/null || echo "no")
    
    if [ "$GITHUB_APP_CONFIGURED" != "yes" ]; then
        echo -e "${RED}‚ùå GitHub App not configured${NC}"
        echo ""
        echo -e "${YELLOW}Please configure GitHub App credentials first:${NC}"
        echo "  dockup $REMOTE configure-github-app"
        echo ""
        echo -e "${YELLOW}See GITHUB_APP_SETUP.md for detailed instructions.${NC}"
        exit 1
    fi
    
    ssh $REMOTE "
      if [ ! -d '/opt/dockup/apps/$APP_NAME' ]; then
        echo '>> Cloning repository...'
        # Try to get token URL from agent, fallback to direct URL
        CLONE_URL=\"$REPO_URL\"
        if [ -f /etc/dockup/github-app.json ]; then
          # Wait a moment for agent to be ready, then try to get token URL
          sleep 2
          TOKEN_URL=\$(curl -s -m 5 \"http://localhost:8080/github/token-url?repo=$REPO_URL\" 2>/dev/null || echo \"\")
          if [ -n \"\$TOKEN_URL\" ] && [ \"\${TOKEN_URL:0:5}\" != \"Failed\" ] && [ \"\${TOKEN_URL:0:4}\" = \"http\" ]; then
            CLONE_URL=\"\$TOKEN_URL\"
            echo '>> Using GitHub App token for cloning...'
          else
            echo '>> Warning: Could not get token from agent, trying direct clone...'
            echo '>> Make sure agent is running: systemctl status dockup'
          fi
        fi
        if ! git clone \"\$CLONE_URL\" /opt/dockup/apps/$APP_NAME 2>&1; then
          echo 'ERROR: Failed to clone repository.'
          echo ''
          echo 'Make sure:'
          echo '  1. GitHub App is configured: dockup $REMOTE configure-github-app'
          echo '  2. GitHub App is installed on the repository'
          REPO_NAME=\$(echo \"$REPO_URL\" | sed 's|.*github.com[:/]||' | sed 's|\\.git\$||' | sed 's|/\$||')
          echo \"     Go to: https://github.com/\$REPO_NAME/settings/installations\"
          echo '  3. The repository URL is correct: $REPO_URL'
          echo '  4. DockUp agent is running: systemctl status dockup'
          echo ''
          echo 'See GITHUB_APP_SETUP.md for setup instructions.'
          exit 1
        fi
      else
        echo '>> Repository already exists, skipping clone...'
      fi
      
      echo '>> Registering app in DockUp...'
      tmp=\$(mktemp)
      jq '.\"$APP_NAME\" = {path: \"/opt/dockup/apps/$APP_NAME\", branch: \"$BRANCH\", secret: \"$SECRET\"}' /etc/dockup/registry.json > \$tmp && mv \$tmp /etc/dockup/registry.json
      
      echo '>> Restarting DockUp agent...'
      systemctl restart dockup
    " || {
        echo -e "${RED}‚ùå Failed to setup on VPS${NC}"
        exit 1
    }

    # 3. GitHub Webhook Setup
    VPS_IP="${REMOTE#*@}"  # Extract IP from user@ip
    WEBHOOK_URL="http://${VPS_IP}:8080/webhook/github"
    
    # Extract repo name from various GitHub URL formats
    # Handles: git@github.com:user/repo.git, https://github.com/user/repo.git, etc.
    # Extract repo name from GitHub URL (handles both SSH and HTTPS formats)
    # Use a more portable approach that works on both macOS and Linux
    if echo "$REPO_URL" | grep -q "github.com"; then
        REPO_FULL_NAME=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)|\1|' | sed 's|\.git$||' | sed 's|/$||')
    else
        REPO_FULL_NAME=""
    fi
    
    echo ""
    echo -e "${GREEN}‚úÖ App registered successfully!${NC}"
    
    # Track app registration metric
    VPS_IP="${REMOTE#*@}"
    METRICS_PAYLOAD=$(cat <<EOF
{
  "event_type": "app_registered",
  "app_name": "$APP_NAME",
  "data": {
    "branch": "$BRANCH"
  }
}
EOF
)
    curl -s -X POST -H "Content-Type: application/json" -d "$METRICS_PAYLOAD" "http://${VPS_IP}:8080/metrics/track" > /dev/null 2>&1 || true
    
    echo ""
    echo -e "${YELLOW}üìã Next Steps:${NC}"
    echo ""
    
    if [ -n "$REPO_FULL_NAME" ] && echo "$REPO_FULL_NAME" | grep -q '/'; then
        echo -e "${YELLOW}1. Ensure GitHub App is installed on repository:${NC}"
        echo "   https://github.com/$REPO_FULL_NAME/settings/installations"
        echo "   Make sure your GitHub App is installed and has access"
        echo ""
        echo -e "${YELLOW}2. Add GitHub Webhook:${NC}"
        echo "   https://github.com/$REPO_FULL_NAME/settings/hooks"
        echo "   Click 'Add webhook' and enter:"
    else
        echo -e "${YELLOW}1. Ensure GitHub App is installed on repository:${NC}"
        echo "   Go to your repository Settings ‚Üí GitHub Apps"
        echo "   Make sure your GitHub App is installed and has access"
        echo ""
        echo -e "${YELLOW}2. Add GitHub Webhook:${NC}"
        echo "   Go to your repository Settings ‚Üí Webhooks"
        echo "   Click 'Add webhook' and enter:"
    fi
    
    echo ""
    echo -e "   ${BLUE}Payload URL:${NC}    $WEBHOOK_URL"
    echo -e "   ${BLUE}Content type:${NC}   application/json"
    echo -e "   ${BLUE}Secret:${NC}         $SECRET"
    echo -e "   ${BLUE}Events:${NC}         Just the push event"
    echo ""
    echo -e "${YELLOW}3. Set up environment files (.env):${NC}"
    echo "   Ensure all required .env files are present on the VPS at:"
    echo "   /opt/dockup/apps/$APP_NAME/"
    echo ""
    echo "   You can copy them manually via:"
    echo "   scp .env $REMOTE:/opt/dockup/apps/$APP_NAME/"
    echo ""
    echo "   ${YELLOW}‚ö†Ô∏è  Important:${NC} Services will fail to start without required .env files!"
    echo ""
    
    # Offer to copy .env files
    copy_env_files "$REMOTE" "$APP_NAME"
    
    # Try to add webhook via GitHub App (preferred) or GitHub CLI (fallback)
    WEBHOOK_EXISTS=false
    if [ -n "$REPO_FULL_NAME" ] && echo "$REPO_FULL_NAME" | grep -q '/'; then
        # First, try using GitHub App via agent endpoint
        if ssh $REMOTE "test -f /etc/dockup/github-app.json" 2>/dev/null; then
            echo -e "${GREEN}üîó Attempting to add webhook via GitHub App...${NC}"
            
            WEBHOOK_JSON=$(cat <<EOF
{
  "repo": "$REPO_FULL_NAME",
  "url": "$WEBHOOK_URL",
  "secret": "$SECRET"
}
EOF
)
            
            HOOK_RESPONSE=$(ssh $REMOTE "curl -s -X POST -H 'Content-Type: application/json' -d '$WEBHOOK_JSON' http://localhost:8080/github/create-webhook" 2>/dev/null || echo "")
            
            if echo "$HOOK_RESPONSE" | grep -q '"status"'; then
                HOOK_STATUS=$(echo "$HOOK_RESPONSE" | jq -r '.status' 2>/dev/null || echo "")
                HOOK_ID=$(echo "$HOOK_RESPONSE" | jq -r '.id' 2>/dev/null || echo "")
                
                if [ "$HOOK_STATUS" = "created" ] || [ "$HOOK_STATUS" = "exists" ]; then
                    echo -e "${GREEN}‚úÖ Webhook added via GitHub App (ID: $HOOK_ID)${NC}"
                    WEBHOOK_EXISTS=true
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Could not create webhook via GitHub App${NC}"
                fi
            fi
        fi
        
        # Fallback to GitHub CLI if GitHub App method didn't work
        if [ "$WEBHOOK_EXISTS" = false ] && command -v gh &> /dev/null; then
            if gh auth status &> /dev/null; then
                echo -e "${BLUE}üîó Attempting to add webhook via GitHub CLI...${NC}"
                
                # Check if webhook already exists
                EXISTING_HOOK=$(gh api "repos/$REPO_FULL_NAME/hooks" --jq ".[] | select(.config.url == \"$WEBHOOK_URL\") | .id" 2>/dev/null | head -n1)
                
                if [ -n "$EXISTING_HOOK" ]; then
                    echo -e "${GREEN}‚úÖ Webhook already exists (ID: $EXISTING_HOOK)${NC}"
                    WEBHOOK_EXISTS=true
                else
                    # Create new webhook
                    # Store stderr separately to capture any errors
                    HOOK_STDERR=$(mktemp)
                    HOOK_RESPONSE=$(gh api "repos/$REPO_FULL_NAME/hooks" \
                        -X POST \
                        -f name=web \
                        -f active=true \
                        -f "config[url]=$WEBHOOK_URL" \
                        -f "config[content_type]=json" \
                        -f "config[secret]=$SECRET" \
                        -f "events[]=push" 2>"$HOOK_STDERR")
                    HOOK_EXIT_CODE=$?
                    HOOK_ERROR=$(cat "$HOOK_STDERR" 2>/dev/null || echo "")
                    rm -f "$HOOK_STDERR"
                    
                    # Combine stdout and stderr for error checking
                    FULL_RESPONSE="${HOOK_RESPONSE}${HOOK_ERROR}"
                    
                    if [ $HOOK_EXIT_CODE -eq 0 ]; then
                        echo -e "${GREEN}‚úÖ Webhook added automatically!${NC}"
                        WEBHOOK_EXISTS=true
                    else
                        # Check if error is because webhook already exists
                        if echo "$FULL_RESPONSE" | grep -qi "already exists\|duplicate\|422"; then
                            echo -e "${GREEN}‚úÖ Webhook already exists${NC}"
                            WEBHOOK_EXISTS=true
                        elif echo "$FULL_RESPONSE" | grep -qi "401\|unauthorized"; then
                            echo -e "${YELLOW}‚ö†Ô∏è  Authentication error${NC}"
                            echo -e "${YELLOW}   Please run: gh auth login${NC}"
                            echo -e "${YELLOW}   Please add it manually using the instructions above.${NC}"
                        elif echo "$FULL_RESPONSE" | grep -qi "403\|forbidden"; then
                            echo -e "${YELLOW}‚ö†Ô∏è  Permission denied${NC}"
                            echo -e "${YELLOW}   Make sure you have 'admin' or 'write' access to the repository${NC}"
                            echo -e "${YELLOW}   Repository: $REPO_FULL_NAME${NC}"
                            echo -e "${YELLOW}   Please add it manually using the instructions above.${NC}"
                        elif echo "$FULL_RESPONSE" | grep -qi "404\|not found"; then
                            echo -e "${YELLOW}‚ö†Ô∏è  Repository not found${NC}"
                            echo -e "${YELLOW}   Check that the repository exists and you have access: $REPO_FULL_NAME${NC}"
                            echo -e "${YELLOW}   Please add it manually using the instructions above.${NC}"
                        else
                            echo -e "${YELLOW}‚ö†Ô∏è  Could not add webhook automatically.${NC}"
                            if [ -n "$FULL_RESPONSE" ]; then
                                ERROR_MSG=$(echo "$FULL_RESPONSE" | head -n5 | grep -v "^$" | head -n1 | cut -c1-200)
                                if [ -n "$ERROR_MSG" ]; then
                                    echo -e "${YELLOW}   Error: $ERROR_MSG${NC}"
                                fi
                            fi
                            echo -e "${YELLOW}   Please add it manually using the instructions above.${NC}"
                        fi
                    fi
                fi
            fi
            
            if [ "$WEBHOOK_EXISTS" = true ]; then
                echo ""
                echo -e "${GREEN}üéâ Setup Complete! Push to '$BRANCH' to deploy.${NC}"
                echo ""
                return
            fi
        else
            echo -e "${YELLOW}üí° Tip: Run 'gh auth login' to enable automatic webhook setup.${NC}"
        fi
    else
        if [ -z "$REPO_FULL_NAME" ] || ! echo "$REPO_FULL_NAME" | grep -q '/'; then
            echo -e "${YELLOW}üí° Could not detect GitHub repository. Please add webhook manually.${NC}"
        elif ! command -v gh &> /dev/null; then
            echo -e "${YELLOW}üí° Tip: Install GitHub CLI ('gh') and run 'gh auth login' for automatic webhook setup.${NC}"
        fi
    fi
    
    echo ""
    echo -e "${GREEN}üéâ Once webhook is added, push to '$BRANCH' to deploy!${NC}"
    echo ""
}

# --- Command: DEPLOY (Unified - Setup + Init + Deploy) ---
cmd_deploy() {
    # Check for updates
    check_for_updates
    
    # First argument is REMOTE, second is the rebuild flag (--rebuild or empty)
    REMOTE="$1"
    REBUILD_FLAG="$2"
    
    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host deploy [--rebuild]${NC}"
        echo ""
        echo "This command will:"
        echo "  1. Check if DockUp is installed on VPS (setup if needed)"
        echo "  2. Register your repo if not already registered"
        echo "  3. Trigger a build and deploy"
        exit 1
    fi

    # Check if we're in a git repo
    if ! git rev-parse --show-toplevel > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Error: Not a Git repository${NC}"
        echo -e "${YELLOW}The 'deploy' command must be run from inside your project's Git repository.${NC}"
        exit 1
    fi

    APP_NAME=$(basename `git rev-parse --show-toplevel`)
    REPO_URL=$(git config --get remote.origin.url)
    
    if [ -z "$REPO_URL" ]; then
        echo -e "${RED}‚ùå Error: No Git remote found${NC}"
        echo -e "${YELLOW}Please add a remote origin to your repository:${NC}"
        echo -e "${YELLOW}  git remote add origin <your-repo-url>${NC}"
        exit 1
    fi

    BRANCH=$(git rev-parse --abbrev-ref HEAD)

    print_version
    echo ""
    echo -e "${GREEN}üöÄ Deploying '$APP_NAME' to $REMOTE...${NC}"
    echo ""

    # Step 1: Check if DockUp is installed on VPS
    echo -e "${BLUE}üìã Step 1: Checking DockUp installation...${NC}"
    if ! ssh $REMOTE "systemctl is-active --quiet dockup 2>/dev/null" && \
       ! ssh $REMOTE "test -f /usr/local/bin/dockup-agent" 2>/dev/null; then
        echo -e "${YELLOW}   DockUp not found. Setting up...${NC}"
        # Call setup with the remote as argument
        cmd_setup "$REMOTE"
        echo ""
    else
        echo -e "${GREEN}   ‚úì DockUp is installed${NC}"
    fi

    # Step 2: Check if repo is registered, register if not
    echo -e "${BLUE}üìã Step 2: Checking repository registration...${NC}"
    REGISTERED=$(ssh $REMOTE "jq -r '.\"$APP_NAME\" // empty' /etc/dockup/registry.json 2>/dev/null" || echo "")
    
    if [ -z "$REGISTERED" ] || [ "$REGISTERED" = "null" ]; then
        echo -e "${YELLOW}   Repository not registered. Registering...${NC}"
        # Run init logic but skip webhook setup (we'll do it at the end)
        SECRET=$(openssl rand -hex 20)
        
        # Check if GitHub App is configured
        GITHUB_APP_CONFIGURED=$(ssh $REMOTE "test -f /etc/dockup/github-app.json && echo 'yes' || echo 'no'" 2>/dev/null || echo "no")
        
        if [ "$GITHUB_APP_CONFIGURED" != "yes" ]; then
            echo -e "${RED}   ‚ùå GitHub App not configured${NC}"
            echo -e "${YELLOW}   Please run: dockup $REMOTE configure-github-app${NC}"
            exit 1
        fi
        
        ssh $REMOTE "
          if [ ! -d '/opt/dockup/apps/$APP_NAME' ]; then
            echo '   >> Cloning repository...'
            # Try to get token URL from agent, fallback to direct URL
            CLONE_URL=\"$REPO_URL\"
            if [ -f /etc/dockup/github-app.json ]; then
              # Wait a moment for agent to be ready, then try to get token URL
              sleep 2
              # URL encode the repo URL for the query parameter
              ENCODED_REPO=\$(echo \"$REPO_URL\" | sed 's|#|%23|g' | sed 's|&|%26|g')
              TOKEN_URL=\$(curl -s -m 5 \"http://localhost:8080/github/token-url?repo=\$ENCODED_REPO\" 2>/dev/null)
              # Check if we got a valid URL (starts with http and doesn't contain error messages)
              if [ -n \"\$TOKEN_URL\" ] && [ \"\${TOKEN_URL:0:4}\" = \"http\" ] && [ \"\${TOKEN_URL:0:5}\" != \"Failed\" ] && echo \"\$TOKEN_URL\" | grep -q 'github.com' 2>/dev/null; then
                CLONE_URL=\"\$TOKEN_URL\"
                echo '   >> Using GitHub App token for cloning...'
              else
                echo '   >> Warning: Could not get token from agent (status: '\$(systemctl is-active dockup 2>/dev/null || echo unknown)')'
                echo '   >> Trying direct clone (this may fail if GitHub App is required)...'
              fi
            fi
            if ! git clone \"\$CLONE_URL\" /opt/dockup/apps/$APP_NAME 2>&1; then
              echo 'ERROR: Failed to clone repository.'
              echo ''
              echo 'Make sure:'
              echo '  1. GitHub App is configured: dockup $REMOTE configure-github-app'
              echo '  2. GitHub App is installed on the repository'
              REPO_NAME=\$(echo \"$REPO_URL\" | sed 's|.*github.com[:/]||' | sed 's|\\.git\$||' | sed 's|/\$||')
              echo \"     Go to: https://github.com/\$REPO_NAME/settings/installations\"
              echo '  3. The repository URL is correct: $REPO_URL'
              echo '  4. DockUp agent is running: systemctl status dockup'
              echo ''
              echo 'See GITHUB_APP_SETUP.md for setup instructions.'
              exit 1
            fi
          else
            echo '   >> Repository already exists, skipping clone...'
          fi
          
          echo '   >> Registering app in DockUp...'
          tmp=\$(mktemp)
          jq '.\"$APP_NAME\" = {path: \"/opt/dockup/apps/$APP_NAME\", branch: \"$BRANCH\", secret: \"$SECRET\"}' /etc/dockup/registry.json > \$tmp && mv \$tmp /etc/dockup/registry.json
          
          echo '   >> Restarting DockUp agent...'
          systemctl restart dockup
        " || {
            echo -e "${RED}‚ùå Failed to register repository${NC}"
            exit 1
        }
        echo -e "${GREEN}   ‚úì Repository registered${NC}"
        echo ""
        echo -e "${YELLOW}   ‚ö†Ô∏è  Reminder:${NC} Ensure all required .env files are present on the VPS"
        echo -e "   ${YELLOW}   Location:${NC} /opt/dockup/apps/$APP_NAME/"
        echo -e "   ${YELLOW}   Copy via:${NC} scp .env $REMOTE:/opt/dockup/apps/$APP_NAME/"
        echo ""
        
        # Offer to copy .env files
        copy_env_files "$REMOTE" "$APP_NAME"
        
        # Get the secret for webhook setup
        SECRET=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".secret' /etc/dockup/registry.json")
    else
        echo -e "${GREEN}   ‚úì Repository already registered${NC}"
        SECRET=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".secret' /etc/dockup/registry.json")
        
        # Reload agent registry to ensure it has the latest config
        # Try reload endpoint first (faster), fallback to restart if needed
        echo -e "${BLUE}   Reloading agent registry...${NC}"
        RELOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "http://${VPS_IP}:8080/reload" 2>/dev/null || echo -e "\n000")
        RELOAD_CODE=$(echo "$RELOAD_RESPONSE" | tail -n1)
        
        if [ "$RELOAD_CODE" != "200" ]; then
            # Reload endpoint not available or failed, restart agent
            ssh $REMOTE "systemctl restart dockup" || true
            sleep 2  # Give agent time to start
        fi
    fi

    # Step 3: Trigger build and deploy
    echo -e "${BLUE}üìã Step 3: Building and deploying...${NC}"
    VPS_IP="${REMOTE#*@}"
    
    if [ "$REBUILD_FLAG" = "--rebuild" ]; then
        echo -e "${YELLOW}   Force rebuild requested...${NC}"
    fi

    # Verify app is registered and get secret
    if [ -z "$SECRET" ] || [ "$SECRET" = "null" ]; then
        echo -e "${YELLOW}   ‚ö†Ô∏è  Could not retrieve secret for app '$APP_NAME'${NC}"
        echo -e "${YELLOW}   Deployment will happen on next git push${NC}"
    else
        # Trigger manual deploy via API
        echo -e "${BLUE}   Triggering deployment...${NC}"
        DEPLOY_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $SECRET" \
            "http://${VPS_IP}:8080/webhook/manual?app=${APP_NAME}" 2>/dev/null)
        
        # Extract HTTP code (last line) and response body (all but last line)
        # Use sed for portability (head -n-1 doesn't work on macOS)
        HTTP_CODE=$(echo "$DEPLOY_RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$DEPLOY_RESPONSE" | sed '$d')
        
        if [ "$HTTP_CODE" = "200" ]; then
            echo -e "${GREEN}   ‚úì Deployment triggered successfully${NC}"
            echo ""
            echo -e "${GREEN}‚úÖ Deployment in progress!${NC}"
            echo ""
            echo -e "${YELLOW}üí° Monitor deployment logs:${NC}"
            echo "   ssh $REMOTE 'journalctl -u dockup -f'"
        elif [ "$HTTP_CODE" = "404" ]; then
            echo -e "${YELLOW}   ‚ö†Ô∏è  App '$APP_NAME' not found in DockUp registry${NC}"
            echo -e "${YELLOW}   This might mean the registry needs to be reloaded${NC}"
            echo -e "${YELLOW}   Deployment will happen on next git push${NC}"
        elif [ "$HTTP_CODE" = "401" ]; then
            echo -e "${YELLOW}   ‚ö†Ô∏è  Authentication failed (HTTP 401)${NC}"
            echo -e "${YELLOW}   Deployment will happen on next git push${NC}"
        else
            echo -e "${YELLOW}   ‚ö†Ô∏è  Could not trigger via API (HTTP $HTTP_CODE)${NC}"
            echo -e "${YELLOW}   Deployment will happen on next git push${NC}"
        fi
    fi

    # Step 4: Webhook setup reminder (only if not already set up)
    echo ""
    # Extract repo name from GitHub URL (handles both SSH and HTTPS formats)
    # Use a more portable approach that works on both macOS and Linux
    if echo "$REPO_URL" | grep -q "github.com"; then
        REPO_FULL_NAME=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)|\1|' | sed 's|\.git$||' | sed 's|/$||')
    else
        REPO_FULL_NAME=""
    fi
    WEBHOOK_URL="http://${VPS_IP}:8080/webhook/github"
    
    if [ -n "$REPO_FULL_NAME" ] && echo "$REPO_FULL_NAME" | grep -q '/'; then
        # Try automatic webhook setup first
        WEBHOOK_EXISTS=false
        echo -e "${BLUE}üìã Step 4: Setting up GitHub webhook...${NC}"
        
        # First, try using GitHub App via agent endpoint
        if ssh $REMOTE "test -f /etc/dockup/github-app.json" 2>/dev/null; then
            WEBHOOK_JSON=$(cat <<EOF
{
  "repo": "$REPO_FULL_NAME",
  "url": "$WEBHOOK_URL",
  "secret": "$SECRET"
}
EOF
)
            
            HOOK_RESPONSE=$(ssh $REMOTE "curl -s -X POST -H 'Content-Type: application/json' -d '$WEBHOOK_JSON' http://localhost:8080/github/create-webhook" 2>/dev/null || echo "")
            
            if echo "$HOOK_RESPONSE" | grep -q '"status"'; then
                HOOK_STATUS=$(echo "$HOOK_RESPONSE" | jq -r '.status' 2>/dev/null || echo "")
                HOOK_ID=$(echo "$HOOK_RESPONSE" | jq -r '.id' 2>/dev/null || echo "")
                
                if [ "$HOOK_STATUS" = "created" ] || [ "$HOOK_STATUS" = "exists" ]; then
                    echo -e "${GREEN}   ‚úì Webhook created via GitHub App (ID: $HOOK_ID)${NC}"
                    WEBHOOK_EXISTS=true
                fi
            fi
        fi
        
        # Fallback to GitHub CLI if GitHub App method didn't work
        if [ "$WEBHOOK_EXISTS" = false ] && command -v gh &> /dev/null && gh auth status &> /dev/null; then
            # Check if webhook already exists
            EXISTING_HOOK=$(gh api "repos/$REPO_FULL_NAME/hooks" --jq ".[] | select(.config.url == \"$WEBHOOK_URL\") | .id" 2>/dev/null | head -n1)
            
            if [ -n "$EXISTING_HOOK" ]; then
                echo -e "${GREEN}   ‚úì Webhook already exists (ID: $EXISTING_HOOK)${NC}"
                WEBHOOK_EXISTS=true
            else
                # Create new webhook
                echo -e "${BLUE}   Creating webhook via GitHub CLI...${NC}"
                
                # Create webhook with better error handling
                # Store stderr separately to capture any errors
                HOOK_STDERR=$(mktemp)
                HOOK_RESPONSE=$(gh api "repos/$REPO_FULL_NAME/hooks" \
                    -X POST \
                    -f name=web \
                    -f active=true \
                    -f "config[url]=$WEBHOOK_URL" \
                    -f "config[content_type]=json" \
                    -f "config[secret]=$SECRET" \
                    -f "events[]=push" 2>"$HOOK_STDERR")
                HOOK_EXIT_CODE=$?
                HOOK_ERROR=$(cat "$HOOK_STDERR" 2>/dev/null || echo "")
                rm -f "$HOOK_STDERR"
                
                # Combine stdout and stderr for error checking
                FULL_RESPONSE="${HOOK_RESPONSE}${HOOK_ERROR}"
                
                if [ $HOOK_EXIT_CODE -eq 0 ]; then
                    echo -e "${GREEN}   ‚úì Webhook created successfully!${NC}"
                    WEBHOOK_EXISTS=true
                else
                    # Check if error is because webhook already exists (different error format)
                    if echo "$FULL_RESPONSE" | grep -qi "already exists\|duplicate\|422"; then
                        echo -e "${GREEN}   ‚úì Webhook already exists${NC}"
                        WEBHOOK_EXISTS=true
                    elif echo "$FULL_RESPONSE" | grep -qi "401\|unauthorized"; then
                        echo -e "${YELLOW}   ‚ö†Ô∏è  Authentication error${NC}"
                        echo -e "${YELLOW}   Please run: gh auth login${NC}"
                    elif echo "$FULL_RESPONSE" | grep -qi "403\|forbidden"; then
                        echo -e "${YELLOW}   ‚ö†Ô∏è  Permission denied${NC}"
                        echo -e "${YELLOW}   Make sure you have 'admin' or 'write' access to the repository${NC}"
                        echo -e "${YELLOW}   Repository: $REPO_FULL_NAME${NC}"
                    elif echo "$FULL_RESPONSE" | grep -qi "404\|not found"; then
                        echo -e "${YELLOW}   ‚ö†Ô∏è  Repository not found${NC}"
                        echo -e "${YELLOW}   Check that the repository exists and you have access: $REPO_FULL_NAME${NC}"
                    else
                        echo -e "${YELLOW}   ‚ö†Ô∏è  Could not create webhook automatically${NC}"
                        if [ -n "$FULL_RESPONSE" ]; then
                            # Show first few lines of error, but limit length
                            ERROR_MSG=$(echo "$FULL_RESPONSE" | head -n5 | grep -v "^$" | head -n1 | cut -c1-200)
                            if [ -n "$ERROR_MSG" ]; then
                                echo -e "${YELLOW}   Error: $ERROR_MSG${NC}"
                            fi
                        fi
                    fi
                fi
            fi
            echo ""
        fi
        
        # Show manual instructions if webhook wasn't created automatically
        if [ "$WEBHOOK_EXISTS" = false ]; then
            echo -e "${YELLOW}üìã Step 4: Add GitHub Webhook manually:${NC}"
            echo "   https://github.com/$REPO_FULL_NAME/settings/hooks"
            echo ""
            echo -e "   ${BLUE}Payload URL:${NC}    $WEBHOOK_URL"
            echo -e "   ${BLUE}Content type:${NC}   application/json"
            echo -e "   ${BLUE}Secret:${NC}         $SECRET"
            echo -e "   ${BLUE}Events:${NC}         Just the push event"
            echo ""
            if ! command -v gh &> /dev/null; then
                echo -e "${YELLOW}üí° Tip: Install GitHub CLI ('gh') and run 'gh auth login' for automatic webhook setup.${NC}"
            elif ! gh auth status &> /dev/null; then
                echo -e "${YELLOW}üí° Tip: Run 'gh auth login' to enable automatic webhook setup.${NC}"
            fi
            echo ""
        fi
    fi

    echo -e "${GREEN}üéâ Deploy complete! Future pushes to '$BRANCH' will auto-deploy.${NC}"
    echo ""
}

# --- Command: DISCONNECT (Unlink project from DockUp) ---
cmd_disconnect() {
    # Check for updates
    check_for_updates
    
    REMOTE="$1"
    APP_NAME_ARG="$2"
    
    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host disconnect [app-name]${NC}"
        echo ""
        echo "This command will:"
        echo "  1. Remove GitHub webhook (if possible)"
        echo "  2. Remove app from DockUp registry"
        echo "  3. Keep app directory and containers running"
        exit 1
    fi

    # Detect app name from git context or use provided argument
    if [ -n "$APP_NAME_ARG" ]; then
        APP_NAME="$APP_NAME_ARG"
    elif git rev-parse --show-toplevel > /dev/null 2>&1; then
        APP_NAME=$(basename `git rev-parse --show-toplevel`)
    else
        echo -e "${RED}‚ùå Error: Not a Git repository and no app name provided${NC}"
        echo -e "${YELLOW}Usage: dockup user@host disconnect [app-name]${NC}"
        echo -e "${YELLOW}Or run from inside your project's Git repository${NC}"
        exit 1
    fi

    print_version
    echo ""
    echo -e "${YELLOW}üîå Disconnecting '$APP_NAME' from DockUp on $REMOTE...${NC}"
    echo ""

    # Check if app is registered
    REGISTERED=$(ssh $REMOTE "jq -r '.\"$APP_NAME\" // empty' /etc/dockup/registry.json 2>/dev/null" || echo "")
    
    if [ -z "$REGISTERED" ] || [ "$REGISTERED" = "null" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  App '$APP_NAME' is not registered in DockUp${NC}"
        exit 0
    fi

    # Get repo info for webhook removal
    REPO_URL=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".path' /etc/dockup/registry.json" 2>/dev/null)
    if [ -n "$REPO_URL" ] && [ -d "$REPO_URL" ]; then
        REPO_URL=$(ssh $REMOTE "cd $REPO_URL && git config --get remote.origin.url 2>/dev/null" || echo "")
    fi

    # Extract GitHub repo name for webhook removal
    if echo "$REPO_URL" | grep -q "github.com"; then
        REPO_FULL_NAME=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)|\1|' | sed 's|\.git$||' | sed 's|/$||')
    else
        REPO_FULL_NAME=""
    fi

    # Step 1: Remove GitHub webhook
    if [ -n "$REPO_FULL_NAME" ] && echo "$REPO_FULL_NAME" | grep -q '/'; then
        echo -e "${BLUE}üìã Step 1: Removing GitHub webhook...${NC}"
        if command -v gh &> /dev/null && gh auth status &> /dev/null; then
            # List webhooks and find the one matching our VPS IP
            VPS_IP="${REMOTE#*@}"
            WEBHOOK_URL="http://${VPS_IP}:8080/webhook/github"
            
            # Get webhook ID
            HOOK_ID=$(gh api "repos/$REPO_FULL_NAME/hooks" --jq ".[] | select(.config.url == \"$WEBHOOK_URL\") | .id" 2>/dev/null | head -n1)
            
            if [ -n "$HOOK_ID" ]; then
                if gh api "repos/$REPO_FULL_NAME/hooks/$HOOK_ID" -X DELETE &> /dev/null; then
                    echo -e "${GREEN}   ‚úì Webhook removed from GitHub${NC}"
                else
                    echo -e "${YELLOW}   ‚ö†Ô∏è  Could not remove webhook automatically${NC}"
                    echo -e "${YELLOW}   Please remove it manually: https://github.com/$REPO_FULL_NAME/settings/hooks${NC}"
                fi
            else
                echo -e "${YELLOW}   ‚ÑπÔ∏è  No matching webhook found (may have been removed already)${NC}"
            fi
        else
            echo -e "${YELLOW}   ‚ÑπÔ∏è  GitHub CLI not available or not authenticated${NC}"
            echo -e "${YELLOW}   Please remove webhook manually: https://github.com/$REPO_FULL_NAME/settings/hooks${NC}"
        fi
        echo ""
    fi

    # Step 2: Remove from registry
    echo -e "${BLUE}üìã Step 2: Removing from DockUp registry...${NC}"
    ssh $REMOTE "
        tmp=\$(mktemp)
        jq 'del(.\"$APP_NAME\")' /etc/dockup/registry.json > \$tmp && mv \$tmp /etc/dockup/registry.json
        echo '   >> Reloading DockUp agent...'
        curl -s -X POST http://localhost:8080/reload > /dev/null 2>&1 || systemctl restart dockup
    " || {
        echo -e "${RED}‚ùå Failed to remove from registry${NC}"
        exit 1
    }
    echo -e "${GREEN}   ‚úì Removed from registry${NC}"
    echo ""

    echo -e "${GREEN}‚úÖ Disconnected '$APP_NAME' from DockUp${NC}"
    echo -e "${YELLOW}‚ÑπÔ∏è  App directory and containers are still running${NC}"
    echo -e "${YELLOW}   Use 'dockup $REMOTE remove' to completely delete the app${NC}"
    echo ""
}

# --- Command: CONFIGURE GITHUB APP ---
cmd_configure_github_app() {
    # Check for updates
    check_for_updates
    
    # Hardcoded App ID for DockUp
    APP_ID="2330335"
    
    # First argument is REMOTE, rest are options
    REMOTE="$1"
    shift
    
    # Parse arguments - $@ contains remaining args after REMOTE
    INSTALLATION_ID=""
    PRIVATE_KEY=""
    
    ARGS=("$@")
    i=0
    while [ $i -lt ${#ARGS[@]} ]; do
        case "${ARGS[$i]}" in
            --installation-id)
                INSTALLATION_ID="${ARGS[$((i+1))]}"
                i=$((i+2))
                ;;
            --private-key)
                PRIVATE_KEY="${ARGS[$((i+1))]}"
                i=$((i+2))
                ;;
            *)
                i=$((i+1))
                ;;
        esac
    done

    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host configure-github-app [--installation-id ID] [--private-key KEY]${NC}"
        echo ""
        echo "This command configures the DockUp GitHub App on your VPS."
        echo ""
        echo -e "${YELLOW}Quick Setup:${NC}"
        echo "  1. Install the DockUp GitHub App on your repositories:"
        echo "     https://github.com/apps/dockup/installations/new"
        echo "  2. Get your Installation ID from the URL after installing"
        echo "  3. Run this command and provide the Installation ID"
        echo ""
        echo "Options:"
        echo "  --installation-id ID  GitHub App Installation ID (required)"
        echo "  --private-key KEY    Private key path (optional, uses default if not provided)"
        echo ""
        echo "Example:"
        echo "  dockup user@vps-ip configure-github-app"
        echo "  dockup user@vps-ip configure-github-app --installation-id 95887454"
        exit 1
    fi

    print_version
    echo ""
    echo -e "${GREEN}üîß Configuring DockUp GitHub App on $REMOTE...${NC}"
    echo ""
    echo -e "${BLUE}Using App ID: $APP_ID (DockUp GitHub App)${NC}"
    echo ""

    # Check if already configured
    EXISTING_CONFIG=$(ssh $REMOTE "test -f /etc/dockup/github-app.json && jq -r '.installation_id // empty' /etc/dockup/github-app.json 2>/dev/null" || echo "")
    if [ -n "$EXISTING_CONFIG" ] && [ "$EXISTING_CONFIG" != "null" ] && [ "$EXISTING_CONFIG" != "" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  GitHub App is already configured${NC}"
        echo -e "${YELLOW}   Current Installation ID: $EXISTING_CONFIG${NC}"
        echo ""
        read -p "Do you want to update it? (y/n): " UPDATE_CONFIRM
        if [ "$UPDATE_CONFIRM" != "y" ] && [ "$UPDATE_CONFIRM" != "Y" ]; then
            echo -e "${YELLOW}Cancelled${NC}"
            exit 0
        fi
        echo ""
    fi

    # Get Installation ID
    if [ -z "$INSTALLATION_ID" ]; then
        echo -e "${YELLOW}üìã Installation ID Required${NC}"
        echo ""
        echo "To get your Installation ID:"
        echo "  1. Go to: https://github.com/apps/dockup/installations"
        echo "  2. Click on your installation (or 'Configure' if not installed)"
        echo "  3. The Installation ID is in the URL:"
        echo "     https://github.com/settings/installations/INSTALLATION_ID"
        echo ""
        echo -e "${BLUE}Or install the app here:${NC}"
        echo "  https://github.com/apps/dockup/installations/new"
        echo ""
        
        # Try to auto-detect if gh CLI is available
        if command -v gh &> /dev/null && gh auth status &> /dev/null; then
            echo -e "${BLUE}üîç Attempting to auto-detect Installation ID...${NC}"
            DETECTED_ID=$(gh api "app/installations" --jq ".[] | select(.app_id == $APP_ID) | .id" 2>/dev/null | head -n1)
            if [ -n "$DETECTED_ID" ]; then
                echo -e "${GREEN}   Found Installation ID: $DETECTED_ID${NC}"
                read -p "Use this Installation ID? (Y/n): " USE_DETECTED
                if [ -z "$USE_DETECTED" ] || [ "$USE_DETECTED" = "y" ] || [ "$USE_DETECTED" = "Y" ]; then
                    INSTALLATION_ID="$DETECTED_ID"
                fi
            fi
        fi
        
        if [ -z "$INSTALLATION_ID" ]; then
            echo ""
            read -p "Enter Installation ID: " INSTALLATION_ID
            if [ -z "$INSTALLATION_ID" ]; then
                echo -e "${RED}‚ùå Installation ID is required${NC}"
                echo ""
                echo -e "${YELLOW}Get it from: https://github.com/apps/dockup/installations${NC}"
                exit 1
            fi
        fi
    fi

    # Get Private Key (optional - can use a default or prompt)
    if [ -z "$PRIVATE_KEY" ]; then
        echo ""
        echo -e "${YELLOW}üìù Private Key${NC}"
        echo ""
        echo "The private key is required for authentication."
        echo "If you have the .pem file, provide the path or paste the content."
        echo ""
        read -p "Private key file path (or press Enter to paste): " KEY_INPUT
        
        if [ -n "$KEY_INPUT" ]; then
            if [ -f "$KEY_INPUT" ]; then
                PRIVATE_KEY=$(cat "$KEY_INPUT")
            else
                echo -e "${RED}‚ùå File not found: $KEY_INPUT${NC}"
                exit 1
            fi
        else
            echo ""
            echo "Paste the private key content (including BEGIN/END lines):"
            echo "Press Enter, paste, then Ctrl+D (or Ctrl+Z on Windows) to finish:"
            PRIVATE_KEY=$(cat)
            if [ -z "$PRIVATE_KEY" ]; then
                echo -e "${RED}‚ùå Private key is required${NC}"
                exit 1
            fi
        fi
    else
        # Check if it's a file path
        if [ -f "$PRIVATE_KEY" ]; then
            PRIVATE_KEY=$(cat "$PRIVATE_KEY")
        fi
    fi

    # Validate private key format
    if ! echo "$PRIVATE_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
        echo -e "${RED}‚ùå Invalid private key format${NC}"
        echo -e "${YELLOW}   The key must include BEGIN and END markers:${NC}"
        echo "   -----BEGIN RSA PRIVATE KEY-----"
        echo "   ..."
        echo "   -----END RSA PRIVATE KEY-----"
        echo ""
        echo -e "${YELLOW}Make sure you copied the entire key from the .pem file.${NC}"
        exit 1
    fi
    
    echo ""
    echo -e "${BLUE}‚úì Validating configuration...${NC}"

    # Create JSON content
    JSON_CONTENT=$(cat <<EOF
{
  "app_id": "$APP_ID",
  "installation_id": "$INSTALLATION_ID",
  "private_key": $(echo "$PRIVATE_KEY" | jq -Rs .)
}
EOF
)

    # Upload and save on VPS
    echo -e "${BLUE}üì¶ Saving GitHub App credentials...${NC}"
    ssh $REMOTE "
        mkdir -p /etc/dockup
        cat > /tmp/github-app.json <<'JSONEOF'
$JSON_CONTENT
JSONEOF
        mv /tmp/github-app.json /etc/dockup/github-app.json
        chmod 600 /etc/dockup/github-app.json
        echo '   >> Credentials saved to /etc/dockup/github-app.json'
    " || {
        echo -e "${RED}‚ùå Failed to save credentials${NC}"
        exit 1
    }

    # Verify it was saved correctly
    VERIFIED=$(ssh $REMOTE "jq -r '.app_id, .installation_id' /etc/dockup/github-app.json 2>/dev/null" || echo "")
    
    if [ -n "$VERIFIED" ]; then
        echo -e "${GREEN}‚úÖ Configuration saved successfully!${NC}"
        echo ""
        echo -e "${YELLOW}üìã Configuration Summary:${NC}"
        echo "  App ID: $APP_ID (DockUp GitHub App)"
        echo "  Installation ID: $INSTALLATION_ID"
        echo "  Location: /etc/dockup/github-app.json"
        echo ""
        
        # Reload agent to pick up new config
        echo -e "${BLUE}üîÑ Reloading DockUp agent...${NC}"
        RELOAD_OUTPUT=$(ssh $REMOTE "curl -s -X POST http://localhost:8080/reload 2>&1" || echo "")
        if echo "$RELOAD_OUTPUT" | grep -q "reloaded\|200"; then
            echo -e "${GREEN}   ‚úì Agent reloaded${NC}"
        else
            echo -e "${YELLOW}   ‚ö†Ô∏è  Reload endpoint not available, restarting agent...${NC}"
            ssh $REMOTE "systemctl restart dockup" || true
            sleep 2
            echo -e "${GREEN}   ‚úì Agent restarted${NC}"
        fi
        echo ""
        
        # Verify the app is installed
        echo -e "${BLUE}üîç Verifying GitHub App installation...${NC}"
        if command -v gh &> /dev/null && gh auth status &> /dev/null; then
            INSTALLATION_INFO=$(gh api "app/installations/$INSTALLATION_ID" 2>/dev/null || echo "")
            if [ -n "$INSTALLATION_INFO" ]; then
                INSTALLED_REPOS=$(echo "$INSTALLATION_INFO" | jq -r '.repository_selection // "unknown"' 2>/dev/null || echo "unknown")
                echo -e "${GREEN}   ‚úì Installation verified${NC}"
                if [ "$INSTALLED_REPOS" = "all" ]; then
                    echo -e "${GREEN}   ‚úì App installed on all repositories${NC}"
                elif [ "$INSTALLED_REPOS" = "selected" ]; then
                    REPO_COUNT=$(echo "$INSTALLATION_INFO" | jq -r '.repositories | length' 2>/dev/null || echo "?")
                    echo -e "${GREEN}   ‚úì App installed on $REPO_COUNT selected repository(ies)${NC}"
                fi
            else
                echo -e "${YELLOW}   ‚ö†Ô∏è  Could not verify installation (this is okay if you just installed)${NC}"
            fi
        else
            echo -e "${YELLOW}   ‚ÑπÔ∏è  Install GitHub CLI and run 'gh auth login' to verify installation${NC}"
        fi
        echo ""
        
        echo -e "${GREEN}üéâ Setup Complete!${NC}"
        echo ""
        echo -e "${YELLOW}Next Steps:${NC}"
        echo "  1. Make sure the DockUp GitHub App is installed on your repositories:"
        echo "     https://github.com/apps/dockup/installations"
        echo ""
        echo "  2. Deploy your first repository:"
        echo "     cd your-project"
        echo "     dockup $REMOTE deploy"
        echo ""
    else
        echo -e "${RED}‚ùå Failed to verify configuration${NC}"
        echo -e "${YELLOW}   Check that the file was created correctly on the VPS${NC}"
        exit 1
    fi
}

# --- Helper: Generate VPS ID from system snapshot ---
generate_vps_id() {
    REMOTE="$1"
    
    # Get system information from remote VPS
    SYS_INFO=$(ssh $REMOTE "
        # Get OS distribution (lowercase, simplified)
        if [ -f /etc/os-release ]; then
            OS=\$(grep '^ID=' /etc/os-release | cut -d'=' -f2 | tr -d '\"' | tr '[:upper:]' '[:lower:]')
        else
            OS=\$(uname -s | tr '[:upper:]' '[:lower:]')
        fi
        
        # Get RAM in GB (round to nearest GB)
        RAM_KB=\$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print \$2}' || echo '0')
        if [ \"\$RAM_KB\" != '0' ]; then
            RAM_GB=\$((RAM_KB / 1024 / 1024))
            # Round up if there's a remainder
            if [ \$((RAM_KB % 1048576)) -gt 0 ]; then
                RAM_GB=\$((RAM_GB + 1))
            fi
        else
            RAM_GB='unknown'
        fi
        
        # Get location/region identifier
        # Try to get from hostname, provider metadata, or default
        LOCATION='unknown'
        
        # Try Hetzner metadata
        if curl -s -m 2 http://169.254.169.254/hetzner/v1/metadata/hostname > /dev/null 2>&1; then
            LOCATION=\$(curl -s -m 2 http://169.254.169.254/hetzner/v1/metadata/datacenter 2>/dev/null | tr '[:upper:]' '[:lower:]' || echo 'unknown')
        fi
        
        # Try DigitalOcean metadata
        if [ \"\$LOCATION\" = 'unknown' ] && curl -s -m 2 http://169.254.169.254/metadata/v1/region > /dev/null 2>&1; then
            LOCATION=\$(curl -s -m 2 http://169.254.169.254/metadata/v1/region 2>/dev/null | tr '[:upper:]' '[:lower:]' || echo 'unknown')
        fi
        
        # Try AWS metadata
        if [ \"\$LOCATION\" = 'unknown' ] && curl -s -m 2 http://169.254.169.254/latest/meta-data/placement/availability-zone > /dev/null 2>&1; then
            LOCATION=\$(curl -s -m 2 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | tr '[:upper:]' '[:lower:]' || echo 'unknown')
        fi
        
        # Fallback: use hostname or generate from IP
        if [ \"\$LOCATION\" = 'unknown' ]; then
            HOSTNAME=\$(hostname 2>/dev/null | tr '[:upper:]' '[:lower:]' || echo '')
            if [ -n \"\$HOSTNAME\" ]; then
                # Extract location-like part from hostname (e.g., fsn1, nyc1)
                LOCATION=\$(echo \"\$HOSTNAME\" | grep -oE '[a-z]{3}[0-9]' | head -1 || echo '')
            fi
            if [ -z \"\$LOCATION\" ]; then
                # Last resort: use first 4 chars of hostname
                LOCATION=\$(echo \"\$HOSTNAME\" | cut -c1-4 | tr '[:upper:]' '[:lower:]' || echo 'vps')
            fi
        fi
        
        # Format: OS-RAM-LOCATION
        echo \"\${OS}-\${RAM_GB}gb-\${LOCATION}\"
    " 2>/dev/null || echo "")
    
    if [ -n "$SYS_INFO" ]; then
        echo "$SYS_INFO"
    else
        # Fallback: generate basic ID
        echo "vps-unknown"
    fi
}

# --- Command: CONFIGURE-METRICS (Configure metrics tracking) ---
cmd_configure_metrics() {
    # Check for updates
    check_for_updates
    
    REMOTE="$1"
    shift
    
    # Parse arguments
    N8N_WEBHOOK_URL="https://n8n2.drninja.net/webhook/dockup"
    VPS_ID=""
    
    ARGS=("$@")
    i=0
    while [ $i -lt ${#ARGS[@]} ]; do
        case "${ARGS[$i]}" in
            --n8n-webhook-url)
                N8N_WEBHOOK_URL="${ARGS[$((i+1))]}"
                i=$((i+2))
                ;;
            --vps-id)
                VPS_ID="${ARGS[$((i+1))]}"
                i=$((i+2))
                ;;
            *)
                i=$((i+1))
                ;;
        esac
    done
    
    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host configure-metrics [--n8n-webhook-url URL] [--vps-id ID]${NC}"
        echo ""
        echo "This command configures metrics tracking for DockUp."
        echo ""
        echo "Options:"
        echo "  --n8n-webhook-url URL  n8n webhook URL for metrics (required)"
        echo "  --vps-id ID            Optional unique identifier for this VPS"
        echo ""
        echo "Example:"
        echo "  dockup user@vps-ip configure-metrics"
        echo "  dockup user@vps-ip configure-metrics --n8n-webhook-url https://n8n.example.com/webhook/dockup"
        exit 1
    fi

    print_version
    echo ""
    echo -e "${GREEN}üìä Configuring metrics tracking on $REMOTE...${NC}"
    echo ""

    # Check if already configured
    EXISTING_CONFIG=$(ssh $REMOTE "test -f /etc/dockup/metrics.json && jq -r '.n8n_webhook_url // empty' /etc/dockup/metrics.json 2>/dev/null" || echo "")
    if [ -n "$EXISTING_CONFIG" ] && [ "$EXISTING_CONFIG" != "null" ] && [ "$EXISTING_CONFIG" != "" ]; then
        EXISTING_VPS_ID=$(ssh $REMOTE "jq -r '.vps_id // empty' /etc/dockup/metrics.json 2>/dev/null" || echo "")
        echo -e "${YELLOW}‚ö†Ô∏è  Metrics tracking is already configured${NC}"
        echo -e "${YELLOW}   Current webhook URL: $EXISTING_CONFIG${NC}"
        if [ -n "$EXISTING_VPS_ID" ] && [ "$EXISTING_VPS_ID" != "null" ]; then
            echo -e "${YELLOW}   Current VPS ID: $EXISTING_VPS_ID${NC}"
        fi
        echo ""
        read -p "Do you want to update it? (y/n): " UPDATE_CONFIRM
        if [ "$UPDATE_CONFIRM" != "y" ] && [ "$UPDATE_CONFIRM" != "Y" ]; then
            echo -e "${YELLOW}Cancelled${NC}"
            exit 0
        fi
        echo ""
    fi

    # Get n8n webhook URL
    if [ -z "$N8N_WEBHOOK_URL" ]; then
        echo -e "${YELLOW}üìã n8n Webhook URL Required${NC}"
        echo ""
        echo "This is the webhook URL from your n8n workflow that will receive metrics events."
        echo "The webhook should be configured to store events in your Supabase database."
        echo ""
        read -p "Enter n8n webhook URL: " N8N_WEBHOOK_URL
        if [ -z "$N8N_WEBHOOK_URL" ]; then
            echo -e "${RED}‚ùå n8n webhook URL is required${NC}"
            exit 1
        fi
    fi

    # Validate URL format
    if ! echo "$N8N_WEBHOOK_URL" | grep -qE "^https?://"; then
        echo -e "${RED}‚ùå Invalid URL format${NC}"
        echo -e "${YELLOW}   URL must start with http:// or https://${NC}"
        exit 1
    fi

    # Get VPS ID (auto-generate if not provided)
    if [ -z "$VPS_ID" ]; then
        echo ""
        echo -e "${BLUE}üîç Generating VPS ID from system snapshot...${NC}"
        GENERATED_VPS_ID=$(generate_vps_id "$REMOTE")
        
        if [ -n "$GENERATED_VPS_ID" ]; then
            echo -e "${GREEN}   Generated VPS ID: $GENERATED_VPS_ID${NC}"
            echo ""
            echo -e "${YELLOW}üìù VPS ID${NC}"
            echo ""
            echo "A unique identifier for this VPS instance based on system snapshot."
            echo "Format: OS-RAM-LOCATION"
            echo ""
            read -p "Use generated VPS ID? (Y/n): " USE_GENERATED
            if [ -z "$USE_GENERATED" ] || [ "$USE_GENERATED" = "y" ] || [ "$USE_GENERATED" = "Y" ]; then
                VPS_ID="$GENERATED_VPS_ID"
            else
                echo ""
                read -p "Enter custom VPS ID (or press Enter to skip): " VPS_ID
            fi
        else
            echo -e "${YELLOW}   ‚ö†Ô∏è  Could not auto-generate VPS ID${NC}"
            echo ""
            echo -e "${YELLOW}üìù VPS ID (Optional)${NC}"
            echo ""
            echo "A unique identifier for this VPS instance (optional)."
            echo "This helps track metrics per-VPS in addition to aggregate statistics."
            echo "You can use any identifier (e.g., hostname, IP, or custom ID)."
            echo ""
            read -p "Enter VPS ID (or press Enter to skip): " VPS_ID
        fi
    fi

    echo ""
    echo -e "${BLUE}‚úì Validating configuration...${NC}"

    # Create JSON content
    if [ -n "$VPS_ID" ]; then
        JSON_CONTENT=$(cat <<EOF
{
  "n8n_webhook_url": "$N8N_WEBHOOK_URL",
  "vps_id": "$VPS_ID"
}
EOF
)
    else
        JSON_CONTENT=$(cat <<EOF
{
  "n8n_webhook_url": "$N8N_WEBHOOK_URL"
}
EOF
)
    fi

    # Upload and save on VPS
    echo -e "${BLUE}üì¶ Saving metrics configuration...${NC}"
    ssh $REMOTE "
        mkdir -p /etc/dockup
        cat > /tmp/metrics.json <<'JSONEOF'
$JSON_CONTENT
JSONEOF
        mv /tmp/metrics.json /etc/dockup/metrics.json
        chmod 600 /etc/dockup/metrics.json
        echo '   >> Configuration saved to /etc/dockup/metrics.json'
    " || {
        echo -e "${RED}‚ùå Failed to save configuration${NC}"
        exit 1
    }

    # Verify it was saved correctly
    VERIFIED=$(ssh $REMOTE "jq -r '.n8n_webhook_url' /etc/dockup/metrics.json 2>/dev/null" || echo "")
    
    if [ -n "$VERIFIED" ]; then
        echo -e "${GREEN}‚úÖ Configuration saved successfully!${NC}"
        echo ""
        echo -e "${YELLOW}üìã Configuration Summary:${NC}"
        echo "  n8n Webhook URL: $N8N_WEBHOOK_URL"
        if [ -n "$VPS_ID" ]; then
            echo "  VPS ID: $VPS_ID"
        else
            echo "  VPS ID: (not set)"
        fi
        echo "  Location: /etc/dockup/metrics.json"
        echo ""
        
        # Reload agent to pick up new config
        echo -e "${BLUE}üîÑ Reloading DockUp agent...${NC}"
        RELOAD_OUTPUT=$(ssh $REMOTE "curl -s -X POST http://localhost:8080/reload 2>&1" || echo "")
        if echo "$RELOAD_OUTPUT" | grep -q "reloaded\|200"; then
            echo -e "${GREEN}   ‚úì Agent reloaded${NC}"
        else
            echo -e "${YELLOW}   ‚ö†Ô∏è  Reload endpoint not available, restarting agent...${NC}"
            ssh $REMOTE "systemctl restart dockup" || true
            sleep 2
            echo -e "${GREEN}   ‚úì Agent restarted${NC}"
        fi
        echo ""
        
        echo -e "${GREEN}üéâ Metrics tracking enabled!${NC}"
        echo ""
        echo -e "${YELLOW}Next Steps:${NC}"
        echo "  Metrics will now be tracked for all deployments and app operations."
        echo "  Make sure your n8n workflow is configured to receive and store these events."
        echo ""
    else
        echo -e "${RED}‚ùå Failed to verify configuration${NC}"
        echo -e "${YELLOW}   Check that the file was created correctly on the VPS${NC}"
        exit 1
    fi
}

# --- Command: REMOVE (Delete project completely) ---
cmd_remove() {
    # Check for updates
    check_for_updates
    
    REMOTE="$1"
    APP_NAME_ARG="$2"
    
    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host remove [app-name]${NC}"
        echo ""
        echo "This command will:"
        echo "  1. Stop and remove containers"
        echo "  2. Remove GitHub webhook (if possible)"
        echo "  3. Remove app from DockUp registry"
        echo "  4. Delete app directory"
        exit 1
    fi

    # Detect app name from git context or use provided argument
    if [ -n "$APP_NAME_ARG" ]; then
        APP_NAME="$APP_NAME_ARG"
    elif git rev-parse --show-toplevel > /dev/null 2>&1; then
        APP_NAME=$(basename `git rev-parse --show-toplevel`)
    else
        echo -e "${RED}‚ùå Error: Not a Git repository and no app name provided${NC}"
        echo -e "${YELLOW}Usage: dockup user@host remove [app-name]${NC}"
        echo -e "${YELLOW}Or run from inside your project's Git repository${NC}"
        exit 1
    fi

    print_version
    echo ""
    echo -e "${RED}üóëÔ∏è  Removing '$APP_NAME' from DockUp on $REMOTE...${NC}"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  This will:${NC}"
    echo "  - Stop and remove all containers"
    echo "  - Remove from DockUp registry"
    echo "  - Delete app directory: /opt/dockup/apps/$APP_NAME"
    echo "  - Remove GitHub webhook"
    echo ""
    read -p "Are you sure? (yes/no): " CONFIRM
    
    if [ "$CONFIRM" != "yes" ]; then
        echo -e "${YELLOW}Cancelled${NC}"
        exit 0
    fi

    # Check if app is registered
    REGISTERED=$(ssh $REMOTE "jq -r '.\"$APP_NAME\" // empty' /etc/dockup/registry.json 2>/dev/null" || echo "")
    
    # Get compose file path
    COMPOSE_FILE="docker-compose.yml"
    if [ -n "$REGISTERED" ] && [ "$REGISTERED" != "null" ]; then
        COMPOSE_FILE=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".compose_file // \"docker-compose.yml\"' /etc/dockup/registry.json" 2>/dev/null || echo "docker-compose.yml")
    fi

    # Get repo info for webhook removal
    APP_PATH=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".path // \"/opt/dockup/apps/$APP_NAME\"' /etc/dockup/registry.json" 2>/dev/null || echo "/opt/dockup/apps/$APP_NAME")
    REPO_URL=""
    if ssh $REMOTE "[ -d \"$APP_PATH\" ]" 2>/dev/null; then
        REPO_URL=$(ssh $REMOTE "cd $APP_PATH && git config --get remote.origin.url 2>/dev/null" || echo "")
    fi

    # Extract GitHub repo name for webhook removal
    if echo "$REPO_URL" | grep -q "github.com"; then
        REPO_FULL_NAME=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)|\1|' | sed 's|\.git$||' | sed 's|/$||')
    else
        REPO_FULL_NAME=""
    fi

    # Step 1: Stop and remove containers
    echo -e "${BLUE}üìã Step 1: Stopping containers...${NC}"
    ssh $REMOTE "
        if [ -d \"$APP_PATH\" ]; then
            cd $APP_PATH
            if [ -f \"$COMPOSE_FILE\" ]; then
                docker compose -f $COMPOSE_FILE down -v 2>/dev/null || true
                echo '   >> Containers stopped and removed'
            else
                echo '   >> No docker-compose.yml found, skipping container removal'
            fi
        else
            echo '   >> App directory not found, skipping container removal'
        fi
    " || echo -e "${YELLOW}   ‚ö†Ô∏è  Could not stop containers (may not exist)${NC}"
    echo ""

    # Step 2: Remove GitHub webhook
    if [ -n "$REPO_FULL_NAME" ] && echo "$REPO_FULL_NAME" | grep -q '/'; then
        echo -e "${BLUE}üìã Step 2: Removing GitHub webhook...${NC}"
        if command -v gh &> /dev/null && gh auth status &> /dev/null; then
            VPS_IP="${REMOTE#*@}"
            WEBHOOK_URL="http://${VPS_IP}:8080/webhook/github"
            
            HOOK_ID=$(gh api "repos/$REPO_FULL_NAME/hooks" --jq ".[] | select(.config.url == \"$WEBHOOK_URL\") | .id" 2>/dev/null | head -n1)
            
            if [ -n "$HOOK_ID" ]; then
                if gh api "repos/$REPO_FULL_NAME/hooks/$HOOK_ID" -X DELETE &> /dev/null; then
                    echo -e "${GREEN}   ‚úì Webhook removed from GitHub${NC}"
                else
                    echo -e "${YELLOW}   ‚ö†Ô∏è  Could not remove webhook automatically${NC}"
                fi
            else
                echo -e "${YELLOW}   ‚ÑπÔ∏è  No matching webhook found${NC}"
            fi
        else
            echo -e "${YELLOW}   ‚ÑπÔ∏è  GitHub CLI not available, please remove webhook manually${NC}"
        fi
        echo ""
    fi

    # Step 3: Remove from registry
    echo -e "${BLUE}üìã Step 3: Removing from DockUp registry...${NC}"
    ssh $REMOTE "
        tmp=\$(mktemp)
        jq 'del(.\"$APP_NAME\")' /etc/dockup/registry.json > \$tmp && mv \$tmp /etc/dockup/registry.json
        echo '   >> Reloading DockUp agent...'
        curl -s -X POST http://localhost:8080/reload > /dev/null 2>&1 || systemctl restart dockup
    " || {
        echo -e "${YELLOW}   ‚ö†Ô∏è  Could not remove from registry (may not exist)${NC}"
    }
    echo -e "${GREEN}   ‚úì Removed from registry${NC}"
    echo ""

    # Step 4: Delete app directory
    echo -e "${BLUE}üìã Step 4: Deleting app directory...${NC}"
    ssh $REMOTE "
        if [ -d \"$APP_PATH\" ]; then
            rm -rf \"$APP_PATH\"
            echo '   >> App directory deleted'
        else
            echo '   >> App directory not found (may have been deleted already)'
        fi
    " || {
        echo -e "${YELLOW}   ‚ö†Ô∏è  Could not delete app directory${NC}"
    }
    echo -e "${GREEN}   ‚úì Directory removed${NC}"
    echo ""

    # Track app removal metric
    VPS_IP="${REMOTE#*@}"
    METRICS_PAYLOAD=$(cat <<EOF
{
  "event_type": "app_removed",
  "app_name": "$APP_NAME",
  "data": {}
}
EOF
)
    curl -s -X POST -H "Content-Type: application/json" -d "$METRICS_PAYLOAD" "http://${VPS_IP}:8080/metrics/track" > /dev/null 2>&1 || true

    echo -e "${GREEN}‚úÖ Completely removed '$APP_NAME' from DockUp${NC}"
    echo ""
}

# --- Command: LIST (List registered apps) ---
# Note: If commands/list.sh exists, it will override this function
if ! type cmd_list >/dev/null 2>&1; then
cmd_list() {
    REMOTE="$1"
    
    if [ -z "$REMOTE" ]; then 
        echo -e "${RED}Usage: ./dockup user@host list${NC}" >&2
        exit 1
    fi
    
    # Check for updates (don't fail if this fails)
    check_for_updates || true

    print_version
    echo ""
    echo -e "${GREEN}üìã Registered Apps on $REMOTE${NC}"
    echo ""

    # Check SSH connectivity first
    if ! ssh $REMOTE "echo test" >/dev/null 2>&1; then
        echo -e "${RED}‚ùå Cannot connect to $REMOTE${NC}" >&2
        echo -e "${YELLOW}   Check SSH connectivity and credentials${NC}" >&2
        exit 1
    fi
    
    # Check if registry.json exists
    if ! ssh $REMOTE "test -f /etc/dockup/registry.json" 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Registry file not found${NC}" >&2
        echo -e "${YELLOW}   DockUp may not be set up on this VPS${NC}" >&2
        echo -e "${YELLOW}   Run: dockup $REMOTE setup${NC}" >&2
        exit 1
    fi

    # Get registry contents
    REGISTRY_JSON=$(ssh $REMOTE "cat /etc/dockup/registry.json 2>/dev/null" || echo "{}")
    
    # Check if registry is empty
    APP_COUNT=$(echo "$REGISTRY_JSON" | jq 'length' 2>/dev/null || echo "0")
    
    if [ "$APP_COUNT" = "0" ] || [ -z "$APP_COUNT" ]; then
        echo -e "${YELLOW}No apps registered${NC}"
        echo ""
        echo -e "${BLUE}To register an app:${NC}"
        echo "  cd your-project"
        echo "  dockup $REMOTE deploy"
        echo ""
        exit 0
    fi

    # List all apps with details
    echo -e "${BLUE}Found $APP_COUNT registered app(s):${NC}"
    echo ""
    
    # Get all app names - use process substitution to avoid subshell issues
    # Read into array using a method compatible with older bash versions
    APP_NAMES_ARRAY=()
    while IFS= read -r line; do
        [ -n "$line" ] && APP_NAMES_ARRAY+=("$line")
    done < <(ssh $REMOTE "jq -r 'keys[]' /etc/dockup/registry.json" 2>/dev/null)
    
    # Iterate over each app name
    for APP_NAME in "${APP_NAMES_ARRAY[@]}"; do
        [ -z "$APP_NAME" ] && continue  # Skip empty entries
        
        # Get app details for this specific app
        APP_PATH=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".path' /etc/dockup/registry.json" 2>/dev/null)
        APP_BRANCH=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".branch' /etc/dockup/registry.json" 2>/dev/null)
        APP_COMPOSE=$(ssh $REMOTE "jq -r '.\"$APP_NAME\".compose_file // \"docker-compose.yml\"' /etc/dockup/registry.json" 2>/dev/null)
        
        echo -e "${GREEN}üì¶ $APP_NAME${NC}"
        echo -e "   ${BLUE}Path:${NC}        $APP_PATH"
        echo -e "   ${BLUE}Branch:${NC}      $APP_BRANCH"
        echo -e "   ${BLUE}Compose File:${NC} $APP_COMPOSE"
        
        # Check if directory exists
        if ssh $REMOTE "test -d \"$APP_PATH\"" 2>/dev/null; then
            echo -e "   ${GREEN}Status:${NC}      Directory exists"
            
            # Check if compose file exists
            if ssh $REMOTE "test -f \"$APP_PATH/$APP_COMPOSE\"" 2>/dev/null; then
                COMPOSE_EXISTS=true
            else
                COMPOSE_EXISTS=false
            fi
        else
            echo -e "   ${YELLOW}Status:${NC}      Directory not found"
            COMPOSE_EXISTS=false
        fi
        
        # Check docker container state with enhanced logic
        RUNNING_COUNT="0"
        TOTAL_COUNT="0"
        
        if [ "$COMPOSE_EXISTS" = "true" ]; then
            # Method 1: Try docker compose ps (most accurate for compose projects)
            # Use project name based on directory name for better matching
            PROJECT_NAME=$(basename "$APP_PATH" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g')
            
            COMPOSE_PS_OUTPUT=$(ssh $REMOTE "cd \"$APP_PATH\" && docker compose -f \"$APP_COMPOSE\" -p \"$PROJECT_NAME\" ps --format json 2>/dev/null" 2>/dev/null)
            
            if [ -n "$COMPOSE_PS_OUTPUT" ] && [ "$COMPOSE_PS_OUTPUT" != "[]" ]; then
                # Parse compose ps output
                RUNNING_COUNT=$(echo "$COMPOSE_PS_OUTPUT" | jq '[.[] | select(.State == "running")] | length' 2>/dev/null || echo "0")
                TOTAL_COUNT=$(echo "$COMPOSE_PS_OUTPUT" | jq 'length' 2>/dev/null || echo "0")
                
                # Also try without project name (default behavior)
                if [ "$RUNNING_COUNT" = "0" ] || [ -z "$RUNNING_COUNT" ]; then
                    COMPOSE_PS_OUTPUT=$(ssh $REMOTE "cd \"$APP_PATH\" && docker compose -f \"$APP_COMPOSE\" ps --format json 2>/dev/null" 2>/dev/null)
                    if [ -n "$COMPOSE_PS_OUTPUT" ] && [ "$COMPOSE_PS_OUTPUT" != "[]" ]; then
                        RUNNING_COUNT=$(echo "$COMPOSE_PS_OUTPUT" | jq '[.[] | select(.State == "running")] | length' 2>/dev/null || echo "0")
                        TOTAL_COUNT=$(echo "$COMPOSE_PS_OUTPUT" | jq 'length' 2>/dev/null || echo "0")
                    fi
                fi
            fi
            
            # Method 2: Fallback - check containers by name pattern if compose ps failed
            if [ "$RUNNING_COUNT" = "0" ] || [ -z "$RUNNING_COUNT" ] || [ "$TOTAL_COUNT" = "0" ]; then
                # Look for containers that match the app name or directory name
                APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
                PROJECT_NAME_LOWER=$(basename "$APP_PATH" | tr '[:upper:]' '[:lower:]')
                
                # Escape special characters for grep and build pattern
                APP_NAME_ESCAPED=$(echo "$APP_NAME_LOWER" | sed 's/[][\.*^$()+?{|]/\\&/g')
                PROJECT_NAME_ESCAPED=$(echo "$PROJECT_NAME_LOWER" | sed 's/[][\.*^$()+?{|]/\\&/g')
                GREP_PATTERN="($APP_NAME_ESCAPED|$PROJECT_NAME_ESCAPED)"
                
                # Check for running containers matching app name patterns
                # Use eval to properly construct command with variable expansion
                RUNNING_BY_NAME=$(ssh $REMOTE "docker ps --format '{{.Names}}' 2>/dev/null | grep -iE '$GREP_PATTERN' | wc -l" 2>/dev/null | tr -d ' ' || echo "0")
                TOTAL_BY_NAME=$(ssh $REMOTE "docker ps -a --format '{{.Names}}' 2>/dev/null | grep -iE '$GREP_PATTERN' | wc -l" 2>/dev/null | tr -d ' ' || echo "0")
                
                # Use fallback counts if they're higher (more containers found)
                if [ "$RUNNING_BY_NAME" != "0" ] && [ -n "$RUNNING_BY_NAME" ]; then
                    if [ "$RUNNING_BY_NAME" -gt "$RUNNING_COUNT" ] 2>/dev/null || [ "$RUNNING_COUNT" = "0" ]; then
                        RUNNING_COUNT="$RUNNING_BY_NAME"
                        TOTAL_COUNT="$TOTAL_BY_NAME"
                    fi
                fi
            fi
        else
            # Directory doesn't exist or compose file missing - check by name pattern only
            APP_NAME_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
            APP_NAME_ESCAPED=$(echo "$APP_NAME_LOWER" | sed 's/[][\.*^$()+?{|]/\\&/g')
            RUNNING_COUNT=$(ssh $REMOTE "docker ps --format '{{.Names}}' 2>/dev/null | grep -iE '$APP_NAME_ESCAPED' | wc -l" 2>/dev/null | tr -d ' ' || echo "0")
            TOTAL_COUNT=$(ssh $REMOTE "docker ps -a --format '{{.Names}}' 2>/dev/null | grep -iE '$APP_NAME_ESCAPED' | wc -l" 2>/dev/null | tr -d ' ' || echo "0")
        fi
        
        # Normalize counts (handle empty strings and non-numeric values)
        if [ -z "$RUNNING_COUNT" ] || ! echo "$RUNNING_COUNT" | grep -qE '^[0-9]+$'; then
            RUNNING_COUNT="0"
        fi
        if [ -z "$TOTAL_COUNT" ] || ! echo "$TOTAL_COUNT" | grep -qE '^[0-9]+$'; then
            TOTAL_COUNT="0"
        fi
        
        # Display container status
        if [ "$RUNNING_COUNT" != "0" ] && [ "$RUNNING_COUNT" != "" ]; then
            if [ "$TOTAL_COUNT" != "0" ] && [ "$RUNNING_COUNT" = "$TOTAL_COUNT" ]; then
                echo -e "   ${GREEN}Containers:${NC}  $RUNNING_COUNT running"
            elif [ "$TOTAL_COUNT" != "0" ]; then
                echo -e "   ${YELLOW}Containers:${NC}  $RUNNING_COUNT/$TOTAL_COUNT running"
            else
                echo -e "   ${GREEN}Containers:${NC}  $RUNNING_COUNT running"
            fi
        else
            echo -e "   ${YELLOW}Containers:${NC}  Not running"
        fi
        echo ""
    done
}
fi  # End of cmd_list fallback

# --- Interactive Menu Functions ---
# Note: If interactive modules exist, they will override these functions

# Fallback functions if modules aren't loaded
if ! type prompt_remote >/dev/null 2>&1; then
prompt_remote() {
    # Simple fallback - just prompt for remote
    local prompt_text="$1"
    local default_remote="$2"
    if [ -n "$default_remote" ]; then
        echo -e "${BLUE}$prompt_text${NC} (default: $default_remote)" >&2
        read -p "Remote host (user@host): " REMOTE_INPUT
        REMOTE_INPUT="${REMOTE_INPUT:-$default_remote}"
    else
        echo -e "${BLUE}$prompt_text${NC}" >&2
        read -p "Remote host (user@host): " REMOTE_INPUT
    fi
    [ -z "$REMOTE_INPUT" ] && return 1
    echo "$REMOTE_INPUT"
}
fi

if ! type select_app >/dev/null 2>&1; then
select_app() {
    # Simple fallback - try to detect from git or prompt
    local remote="$1"
    if git rev-parse --show-toplevel > /dev/null 2>&1; then
        basename `git rev-parse --show-toplevel`
    else
        read -p "Enter app name: " APP_INPUT
        echo "$APP_INPUT"
    fi
}
fi

# Remote host storage functions
get_remotes_file() {
    local remotes_dir="$HOME/.dockup"
    mkdir -p "$remotes_dir"
    echo "$remotes_dir/remotes.json"
}

# Save a remote host to storage
save_remote() {
    local remote="$1"
    [ -z "$remote" ] && return 1
    
    local remotes_file=$(get_remotes_file)
    local temp_file="${remotes_file}.tmp"
    
    # Check if jq is available
    if command -v jq >/dev/null 2>&1; then
        # Use jq to manage JSON array
        if [ -f "$remotes_file" ] && [ -s "$remotes_file" ]; then
            # Add remote if it doesn't exist, then deduplicate
            jq --arg remote "$remote" 'if (. | index($remote)) then . else . + [$remote] end | unique' "$remotes_file" > "$temp_file" 2>/dev/null
        else
            # Create new array
            printf '%s\n' "$remote" | jq -R -s 'split("\n") | map(select(length > 0))' > "$temp_file" 2>/dev/null
        fi
        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
            mv "$temp_file" "$remotes_file" 2>/dev/null || true
        else
            rm -f "$temp_file" 2>/dev/null || true
        fi
    else
        # Fallback: simple text file, one per line
        if [ ! -f "$remotes_file" ] || ! grep -Fxq "$remote" "$remotes_file" 2>/dev/null; then
            echo "$remote" >> "$remotes_file"
        fi
    fi
}

# Load stored remote hosts
load_remotes() {
    local remotes_file=$(get_remotes_file)
    
    if [ ! -f "$remotes_file" ]; then
        return 0
    fi
    
    # Check if jq is available
    if command -v jq >/dev/null 2>&1; then
        jq -r '.[]' "$remotes_file" 2>/dev/null | grep -v '^$' || true
    else
        # Fallback: read text file
        grep -v '^$' "$remotes_file" 2>/dev/null || true
    fi
}

# Prompt for remote host input with stored remotes as choices
prompt_remote() {
    local prompt_text="$1"
    local default_remote="$2"
    
    # Load stored remotes
    local stored_remotes=()
    while IFS= read -r line; do
        [ -n "$line" ] && stored_remotes+=("$line")
    done < <(load_remotes)
    
    # If we have stored remotes, show them as choices
    if [ ${#stored_remotes[@]} -gt 0 ]; then
        echo -e "${BLUE}$prompt_text${NC}" >&2
        echo -e "${YELLOW}Stored remotes:${NC}" >&2
        local i=1
        for stored in "${stored_remotes[@]}"; do
            echo -e "  ${GREEN}$i)${NC} $stored" >&2
            ((i++))
        done
        echo -e "  ${GREEN}$i)${NC} Enter new remote" >&2
        echo "" >&2
        
        local choice
        read -p "Select remote (1-$i) or enter new: " choice
        
        # Check if choice is a number
        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#stored_remotes[@]} ]; then
                REMOTE_INPUT="${stored_remotes[$((choice-1))]}"
            elif [ "$choice" -eq $i ]; then
                # User wants to enter new remote
                read -p "Remote host (user@host): " REMOTE_INPUT
            else
                echo -e "${RED}‚ùå Invalid choice${NC}" >&2
                return 1
            fi
        else
            # User entered a remote directly
            REMOTE_INPUT="$choice"
        fi
    else
        # No stored remotes, use original prompt
        if [ -n "$default_remote" ]; then
            echo -e "${BLUE}$prompt_text${NC} (default: $default_remote)" >&2
            read -p "Remote host (user@host): " REMOTE_INPUT
            REMOTE_INPUT="${REMOTE_INPUT:-$default_remote}"
        else
            echo -e "${BLUE}$prompt_text${NC}" >&2
            read -p "Remote host (user@host): " REMOTE_INPUT
        fi
    fi
    
    if [ -z "$REMOTE_INPUT" ]; then
        echo -e "${RED}‚ùå Remote host is required${NC}" >&2
        return 1
    fi
    
    # Save the remote for future use
    save_remote "$REMOTE_INPUT"
    
    echo "$REMOTE_INPUT"
}

# Get list of apps from a remote (for selection)
get_apps_from_remote() {
    local remote="$1"
    local apps=()
    
    # Check SSH connectivity
    if ! ssh "$remote" "echo test" >/dev/null 2>&1; then
        return 1
    fi
    
    # Check if registry exists
    if ! ssh "$remote" "test -f /etc/dockup/registry.json" 2>/dev/null; then
        return 1
    fi
    
    # Get app names
    while IFS= read -r line; do
        [ -n "$line" ] && apps+=("$line")
    done < <(ssh "$remote" "jq -r 'keys[]' /etc/dockup/registry.json" 2>/dev/null)
    
    # Output apps (one per line for select menu)
    printf '%s\n' "${apps[@]}"
}

# Interactive app selection
select_app() {
    local remote="$1"
    local apps=()
    
    # Try to get apps from remote
    while IFS= read -r line; do
        [ -n "$line" ] && apps+=("$line")
    done < <(get_apps_from_remote "$remote" 2>/dev/null)
    
    # If no apps found, try to detect from git context
    if [ ${#apps[@]} -eq 0 ]; then
        if git rev-parse --show-toplevel > /dev/null 2>&1; then
            local detected_app=$(basename `git rev-parse --show-toplevel`)
            echo -e "${YELLOW}‚ö†Ô∏è  No apps found on remote. Using detected app: $detected_app${NC}" >&2
            echo "$detected_app"
            return 0
        else
            echo -e "${YELLOW}‚ö†Ô∏è  No apps found and not in a git repository${NC}" >&2
            read -p "Enter app name: " APP_INPUT
            if [ -z "$APP_INPUT" ]; then
                return 1
            fi
            echo "$APP_INPUT"
            return 0
        fi
    fi
    
    # If only one app, return it
    if [ ${#apps[@]} -eq 1 ]; then
        echo "${apps[0]}"
        return 0
    fi
    
    # Multiple apps - show selection menu
    echo "" >&2
    echo -e "${BLUE}Select an app:${NC}" >&2
    echo "" >&2
    
    PS3="Select app (1-${#apps[@]}): "
    select app in "${apps[@]}" "Cancel"; do
        if [ "$app" = "Cancel" ]; then
            return 1
        elif [ -n "$app" ]; then
            echo "$app"
            return 0
        else
            echo -e "${RED}Invalid selection${NC}" >&2
        fi
    done
}

# Interactive main menu
# Note: If interactive/menu.sh exists, it will override this function
if ! type interactive_menu >/dev/null 2>&1; then
interactive_menu() {
    while true; do
        print_version
        echo ""
        echo -e "${GREEN}üöÄ DockUp Interactive CLI${NC}"
        echo ""
        echo -e "${BLUE}Select a command:${NC}"
        echo ""
        
        # Command options with descriptions
        local commands=(
            "deploy:Deploy your app (recommended - handles setup + init + deploy)"
            "setup:One-time VPS setup (install DockUp agent)"
            "init:Register repository (without deploying)"
            "list:List all registered apps"
            "disconnect:Unlink project from DockUp (keeps app running)"
            "remove:Delete project completely"
            "configure-github-app:Configure GitHub App credentials"
            "version:Show version information"
            "help:Show help message"
            "exit:Exit interactive mode"
        )
        
        # Extract command names for select menu
        local cmd_names=()
        for cmd_entry in "${commands[@]}"; do
            IFS=':' read -r cmd_name cmd_desc <<< "$cmd_entry"
            cmd_names+=("$cmd_name")
        done
        
        # Display menu
        PS3="Select command (1-${#cmd_names[@]}): "
        select choice in "${cmd_names[@]}"; do
            if [ -z "$choice" ]; then
                echo -e "${RED}Invalid selection. Please try again.${NC}"
                echo ""
                break
            fi
            
            # Handle special cases
            case "$choice" in
                "exit")
                    echo -e "${BLUE}Goodbye!${NC}"
                    exit 0
                    ;;
                "help")
                    echo ""
                    echo "Usage: dockup user@host {setup|init|deploy|disconnect|remove|list|configure-github-app|version} [options]"
                    echo ""
                    echo "Commands:"
                    echo ""
                    echo -e "${GREEN}  deploy${NC}     - Unified command (RECOMMENDED)"
                    echo "     Automatically handles: setup + init + deploy"
                    echo ""
                    echo -e "${YELLOW}  setup${NC}      - One-time VPS setup"
                    echo "     Installs DockUp agent on your VPS"
                    echo ""
                    echo -e "${YELLOW}  init${NC}       - Register repository"
                    echo "     Registers your repo with DockUp (without deploying)"
                    echo ""
                    echo -e "${BLUE}  list${NC}        - List registered apps"
                    echo "     Shows all apps registered in DockUp registry"
                    echo ""
                    echo -e "${BLUE}  disconnect${NC}  - Unlink project from DockUp"
                    echo "     Removes webhook and registry entry, keeps app directory"
                    echo ""
                    echo -e "${RED}  remove${NC}      - Delete project completely"
                    echo "     Stops containers, removes webhook, deletes app directory"
                    echo ""
                    echo -e "${BLUE}  configure-github-app${NC}  - Configure GitHub App credentials"
                    echo "     Configures GitHub App for repository access"
                    echo ""
                    echo -e "${BLUE}üí° Tip: Most users should use 'deploy' - it does everything!${NC}"
                    echo ""
                    echo -e "${YELLOW}Press Enter to return to menu...${NC}"
                    read
                    break
                    ;;
                "version")
                    cmd_version
                    echo ""
                    echo -e "${YELLOW}Press Enter to return to menu...${NC}"
                    read
                    break
                    ;;
            esac
            
            # Commands that need remote host
            local remote=""
            case "$choice" in
                "setup"|"init"|"deploy"|"list"|"disconnect"|"remove"|"configure-github-app")
                    remote=$(prompt_remote "Enter remote host" "")
                    local prompt_status=$?
                    if [ -z "$remote" ] || [ $prompt_status -ne 0 ]; then
                        echo -e "${RED}‚ùå Remote host is required${NC}"
                        echo ""
                        echo -e "${YELLOW}Press Enter to return to menu...${NC}"
                        read
                        break
                    fi
                    ;;
            esac
            
            # Commands that need app selection
            local app_name=""
            case "$choice" in
                "disconnect"|"remove")
                    app_name=$(select_app "$remote")
                    local select_status=$?
                    if [ -z "$app_name" ] || [ $select_status -ne 0 ]; then
                        echo -e "${YELLOW}Cancelled${NC}"
                        echo ""
                        echo -e "${YELLOW}Press Enter to return to menu...${NC}"
                        read
                        break
                    fi
                    ;;
            esac
            
            # Execute the selected command
            echo ""
            case "$choice" in
                "setup")
                    cmd_setup "$remote"
                    ;;
                "init")
                    cmd_init "$remote"
                    ;;
                "deploy")
                    # Ask about rebuild flag
                    echo -e "${BLUE}Force rebuild?${NC}"
                    read -p "Rebuild images even if unchanged? (y/N): " REBUILD_INPUT
                    if [ "$REBUILD_INPUT" = "y" ] || [ "$REBUILD_INPUT" = "Y" ]; then
                        cmd_deploy "$remote" "--rebuild"
                    else
                        cmd_deploy "$remote"
                    fi
                    ;;
                "list")
                    cmd_list "$remote"
                    ;;
                "disconnect")
                    cmd_disconnect "$remote" "$app_name"
                    ;;
                "remove")
                    cmd_remove "$remote" "$app_name"
                    ;;
                "configure-github-app")
                    cmd_configure_github_app "$remote"
                    ;;
                "configure-metrics")
                    cmd_configure_metrics "$remote"
                    ;;
            esac
            
            echo ""
            echo -e "${YELLOW}Press Enter to return to menu...${NC}"
            read
            break
        done
    done
}
fi  # End of interactive_menu fallback

# --- Main Switch ---
# New argument order: dockup user@host command [options]
# Handle version command first (doesn't need remote)
if [ "$1" = "version" ] || [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
    cmd_version
    exit 0
fi

# Interactive mode detection: if no arguments provided, enter interactive mode
if [ $# -eq 0 ]; then
    interactive_menu
    exit 0
fi

REMOTE="$1"
COMMAND="$2"

# Save remote host for future use (if provided)
if [ -n "$REMOTE" ] && [ -n "$COMMAND" ]; then
    save_remote "$REMOTE"
fi

case "$COMMAND" in
    setup)      shift; shift; cmd_setup "$REMOTE" ;;
    init)       shift; shift; cmd_init "$REMOTE" ;;
    deploy)      shift; shift; cmd_deploy "$REMOTE" "$@" ;;
    disconnect) shift; shift; cmd_disconnect "$REMOTE" "$@" ;;
    remove)     shift; shift; cmd_remove "$REMOTE" "$@" ;;
    list)       shift; shift; cmd_list "$REMOTE" ;;
    configure-github-app) shift; shift; cmd_configure_github_app "$REMOTE" "$@" ;;
    configure-metrics) shift; shift; cmd_configure_metrics "$REMOTE" "$@" ;;
    *)
        # Handle old format for backward compatibility (if first arg looks like a command)
        if [ "$1" = "setup" ] || [ "$1" = "init" ] || [ "$1" = "deploy" ] || [ "$1" = "disconnect" ] || [ "$1" = "remove" ] || [ "$1" = "configure-github-app" ] || [ "$1" = "configure-metrics" ] || [ "$1" = "list" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Deprecated argument order detected${NC}"
            echo -e "${YELLOW}   Old format: dockup $1 user@host${NC}"
            echo -e "${YELLOW}   New format: dockup user@host $1${NC}"
            echo ""
            echo -e "${BLUE}Please use the new format: dockup user@host $1${NC}"
            exit 1
        fi
        
        # Show help
        if [ -z "$1" ] || [ "$1" = "help" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
            echo "Usage: dockup user@host {setup|init|deploy|disconnect|remove|list|configure-github-app|configure-metrics|version} [options]"
            echo ""
            echo "Commands:"
            echo ""
            echo -e "${GREEN}  deploy${NC}     - Unified command (RECOMMENDED)"
            echo "     Automatically handles: setup + init + deploy"
            echo "     Use when: You want to deploy your app in one command"
            echo "     Example: dockup user@vps-ip deploy"
            echo "              dockup user@vps-ip deploy --rebuild"
            echo ""
            echo -e "${YELLOW}  setup${NC}      - One-time VPS setup"
            echo "     Installs DockUp agent on your VPS"
            echo "     Use when: First time setting up a new VPS"
            echo "     Example: dockup user@vps-ip setup"
            echo ""
            echo -e "${YELLOW}  init${NC}       - Register repository"
            echo "     Registers your repo with DockUp (without deploying)"
            echo "     Use when: You only want to register, not deploy immediately"
            echo "     Example: dockup user@vps-ip init"
            echo ""
            echo -e "${BLUE}  list${NC}        - List registered apps"
            echo "     Shows all apps registered in DockUp registry"
            echo "     Use when: You want to see what apps are deployed"
            echo "     Example: dockup user@vps-ip list"
            echo ""
            echo -e "${BLUE}  disconnect${NC}  - Unlink project from DockUp"
            echo "     Removes webhook and registry entry, keeps app directory"
            echo "     Use when: You want to stop auto-deployments but keep the app"
            echo "     Example: dockup user@vps-ip disconnect"
            echo "              dockup user@vps-ip disconnect my-app"
            echo ""
            echo -e "${RED}  remove${NC}      - Delete project completely"
            echo "     Stops containers, removes webhook, deletes app directory"
            echo "     Use when: You want to completely remove the app from VPS"
            echo "     Example: dockup user@vps-ip remove"
            echo "              dockup user@vps-ip remove my-app"
            echo ""
            echo -e "${BLUE}  configure-github-app${NC}  - Configure GitHub App credentials"
            echo "     Configures GitHub App for repository access"
            echo "     Use when: First time setup or updating credentials"
            echo "     Example: dockup user@vps-ip configure-github-app"
            echo ""
            echo -e "${BLUE}  configure-metrics${NC}     - Configure metrics tracking"
            echo "     Configures metrics tracking via n8n webhook"
            echo "     Use when: You want to track deployment metrics"
            echo "     Example: dockup user@vps-ip configure-metrics"
            echo ""
            echo -e "${BLUE}üí° Tip: Most users should use 'deploy' - it does everything!${NC}"
        else
            # Invalid command or missing remote
            if [ -z "$REMOTE" ]; then
                echo -e "${RED}Error: Missing remote host${NC}"
                echo "Usage: dockup user@host {setup|init|deploy|disconnect|remove|list|configure-github-app|configure-metrics|version} [options]"
            elif [ -z "$COMMAND" ]; then
                echo -e "${RED}Error: Missing command${NC}"
                echo "Usage: dockup user@host {setup|init|deploy|disconnect|remove|list|configure-github-app|version} [options]"
            else
                echo -e "${RED}Error: Unknown command '$COMMAND'${NC}"
                echo "Usage: dockup user@host {setup|init|deploy|disconnect|remove|list|configure-github-app|version} [options]"
            fi
        fi
        ;;
esac

